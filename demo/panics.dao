
# The error handling in Dao is based defer blocks which can be executed
# unconditionally or conditionally with respect to exceptions.
# Please see the "Defer Blocks" demo for more details.
#
# In Dao, an exception or error can be raised by the built-in function
# error() which has three overloaded versions. The simplest version can
# take a string as parameter to become the message of the error.
#
# To handle an error of certain type, one need to define a defer block
# with the error type as its parameter. Such that the block will only
# be executed when an error of that type actually happened. Then the
# error object will be passed to the defer block for proper handling.
#
# If the error can be recovered, one should handle it in the defer block
# and return a value explicitly. This value will be used as the new return
# value of the routine where the defer block is defined. With the explicit
# return value, the error object will be removed, and allow the routine
# to return normally so that the program can continue to run.
#
# Of course, one can also define a defer block for certain errors, and
# let the errors to propagate by not returning any value explicitly.
#

routine Test()
{
	defer ( Exception::Error ){
		io.writeln( 'Error is handled! And a new value is returned!' )
		return 456
	}
	defer ( Exception::Error ){
		io.writeln( 'Error is NOT handled!' )
	}
	io.writeln( 'Test(): before error;' )
	error( 'some error' )
	io.writeln( 'Test(): after error;' )
	return 123
}

io.writeln( Test() )

# Example to handle user defined exception type:
class MyError : Exception::Error
{
	routine serialize(){ return ('MyError', self) }
}

routine Test2()
{
	defer ( MyError as error ) {
		io.writeln( 'recovering from', error )
		return none
	}

	io.writeln( 'Test3(): before error;' )
	error( MyError() );
	io.writeln( 'Test3(): after error;' )
}

Test2()


# To simplify the handling of panics, Dao support a special type
# of code blocks that are executed in new stack frames. Such blocks
# can be defined in the following ways:
#     frame { block }
#     frame ( value ) { block }
# which are expressions that may return values. In the second case,
# if the "block" raises an exception, the default "value" is returned
# instead, and the exception is suppressed.

fout = io::stdio

frame {
	defer ( any ) { return none }
	fout = io.open( "NonExistentFile.txt", 'r+' )
}

if( fout != io::stdio ) defer{ fout.close() }

fout.writeln( 'hello' )


# A simpler way to write the above codes:
fout = frame( io::stdio ){ io.open( "NonExistentFile.txt", 'r+' ) }

# Or using the assertion operator ??:
# fout = io.open( "NonExistentFile.txt", 'r+' ) ?? io::stdio

if( fout != io::stdio ) defer{ fout.close() }

fout.writeln( 'hello' )
