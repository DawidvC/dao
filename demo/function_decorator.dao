
routine @trace( func : routine )
{
	reflect.trace();
	io.writeln( std.about( func ) );
	return func(...);
}

@trace
routine func(){ io.writeln( 'func()' ); }
@trace
routine func( a : int ){ io.writeln( 'func(int)', a ); }

io.writeln( '=========trace decorator=============' );
func();
func(123);

routine @test( func : routine<index:int=>string>, expected = '' )
{
	res = func( ... );
	io.writeln( res );
	io.writeln( 'check:', res == expected, res, expected );
	return res;
}

@test#( 'hello' )
routine hello( index = 0 )
{
	io.writeln( 'calling hello(int)' );
	return 'hello';
}

io.writeln( '=========test decorator=============' );
hello();

# overloaded decorator:
routine @test( func : routine<name:string=>int>, expected = 0 )
{
	res = func( ... );
	io.writeln( res );
	io.writeln( 'check:', res == expected, res, expected );
	return res;
}

@trace
@test( 123 )
routine hello( name : string )
{
	io.writeln( 'calling hello(string)' );
	return 123;
}

io.writeln( '=========test + trace decorator=============' );
io.writeln( hello( 'abc' ) );

routine hello2( index = 123 )
{
	io.writeln( 'calling hello2(int)', index );
	return 'hello2';
}
# running time decoration:
b = @test( hello2 );
io.writeln( std.about( b ) );
io.writeln( b(123) );
b = @test( b );
io.writeln( b(123) );

d = @trace;
io.writeln( std.about(d) );

e = d(b);

e(789);
