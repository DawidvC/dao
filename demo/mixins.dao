
class Base
{
	var value = 456
	routine Meth2(){ io.writeln( self, value ) }
}

#
# Classes to be used as mixins can be specified in a pair of brackets
# following the class name. Only classes without parent classes can
# be used as mixins.
#
class Mixin ( Base )
{
	var index = 123

	routine Meth(){ io.writeln( self, index, value ) }
	routine Meth2( a : string ){ io.writeln( self, index, value, a ) }
}

#
# The "Base" class will be presented only once in "Klass":
#
class Klass ( Base, Mixin )
{
	var index = 123456
	routine Meth2( a : int ){ io.writeln( self, index, value, a ) }
}

k = Klass()

io.writeln( k.index )

k.Meth()
k.Meth2()
k.Meth2( 'abc' )
k.Meth2( 789 )


#
# When a class is used as a mixin class in another class (host),
# the decorator methods of the mixin will be applied to the methods
# of the host class, if the names of the decorators are started
# (excluding the '@') or ended with a underscore. Such names
# are interpreted as the following patterns:
# 1. The non-underscore-containing substring following the starting
#    underscore is considered as a prefix that a method name must
#    has, as a precondition that the method can be applied with
#    the decorator;
# 2. The non-underscore-containing substring preceding the ending
#    underscore is considered as a suffix that a method name must
#    has, as a precondition that the method can be applied with
#    the decorator;
# 3. If the prefix substring and the suffixing substring of a decorator
#    name are the same substring (not merely the same), only the methods
#    with names that are the same as the prefix (suffix) could be applied
#    with this decorator. 
#
# When multiple mixins are used in a host class, the decorators of the
# first mixin are applied the last. An the first decorator of the same
# decorator is also applied the last as well.
#
class Header
{
	static routine @__Delimiter__( meth : routine ){
		io.writeln( '=======================' )
		return meth( __args__, ... )
	}
	routine @__Delimiter__( meth : routine ){
		io.writeln( '-----------------------' )
		return meth( __args__, ... )
	}
}
class Decorator
{
	var value = 654321

	routine @_Test_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Test_()', value )
		meth( __args__, ... );
	}
	routine @_Prefix( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Prefix()' )
		meth( __args__, ... );
	}
	routine @Suffix_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::Suffix_()' )
		meth( __args__, ... );
	}
	routine @_Prefix_Suffix_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Prefix_Suffix_()' )
		meth( __args__, ... );
	}
}

class MyClass ( Header, Decorator )
{
	routine Test(){
		io.writeln( 'MyClass::Test()' )
	}
	routine PrefixTest(){
		io.writeln( 'MyClass::PrefixTest()' )
	}
	routine TestSuffix(){
		io.writeln( 'MyClass::TestSuffix()' )
	}
	routine PrefixTestSuffix(){
		io.writeln( 'MyClass::PrefixTestSuffix()' )
	}
}

obj = MyClass()
obj.Test()
obj.PrefixTest()
obj.TestSuffix()
obj.PrefixTestSuffix()
