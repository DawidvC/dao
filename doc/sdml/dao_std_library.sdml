<book>Dao Library Reference</book>
<author>Limin Fu (phoolimin@gmail.com)</author>

(For Dao 1.1)


This document is licensed under
<link>GNU Free Documentation License</link>.

<=====>introduction</=====>

This documentation introduces the standard libraries for a number of applications
and the standard methods for various data types.
In the method parameter lists, <%>par : Xyz</%> means parameter <%>par</%> 
should be of the type of <%>Xyz</%>;
<%>par = Xyz</%> means that <%>par</%> has default value <%>Xyz</%>. 
There are also a number of overloaded methods,
which have the same name, but with different parameter lists.
Some methods of one library can be imported to the current namespace by using
"use library;" statement so that the methods can be used directly, e.g.,
<code dao>
use math;
a = cos( 1.5 );
</code>

In the following, the prototypes of methods usually appear as for clarity:
<code dao>
type.method( parameter_list )
</code>
but the real prototypes are defined the following form:
<code dao>
method( self : type, parameter_list )
</code>

<=====>string</=====>

<===>Method list:</===>

<code dao>
chop(  )
erase( start=0, n=-1 )
find( str : string, from=0, reverse=0 ) => int
insert( str : string, index=0 )
replace( str1 : string, str2 : string, index=0 )
replace( str1 : string, table : map<string,string>, max=0 )
expand( keys :map<string,string>, spec='$', keep=1 )
expand( keys : tuple, spec='$', keep=1 )
resize( size : int )
size(  ) => int
split( sep : string, quote="", rm=1 ) => list<string>
tokenize( seps : string, quotes="", backslash=0, simplify=0 ) => list<string>
tonumber( base=10 ) => double
tolower(  ) => string
toupper(  ) => string
encrypt( key : string, hex=0 ) => string
decrypt( key : string, hex=0 ) => string
</code>

There are a few other methods that use regular expression pattern
for string operation, please refer to the <link>Dao Regex Tutorial</link>.

<===>Method details:</===>

<code dao>
string.chop( utf=0 )
</code>
Chop off new line symbol from the end of a string.
If utf=1, chop off the characters that do not form a valid UTF-8 encoding.

<code dao>
string.erase( start=0, n=-1 )
</code>
Erase <%>n</%> characters starting from index <%>start</%>.
If n=-1, erase all the rest.

<code dao>
string.find( str : string, from=0, reverse=0 ) => int
</code>
Find substring <%>str</%>, starting from <%>from</%>; search backward if <%>reverse</%> is true.
Return the index of the occurrence of <%>str</%>, return -1 if not found.

<code dao>
string.insert( str : string, index=0 )
</code>
Insert substring <%>str</%> at <%>index</%>

<code dao>
string.replace( str1 : string, str2 : string, index=0 )
</code>
Replace the <%>index</%>-th occurrence of substring <%>str1</%> to substring <%>str2</%>;
the index starts from 1, which means the first, and 0 means all.

<code dao>
string.replace( table : map<string,string>, max=0 )
</code>
Replace the occurrence of the keys of <it>table</it> by the corresponding values.
If <it>max</it> is zero, replace the shorter key first, otherwise,
replace the longer first.

<code dao>
string.expand( keys : map<string,string>, spec='$', keep=1 ) => string
</code>
If the string contains place holders in form of <it>$(name)</it>,
where <it>$</it> is the special character passed in by <it>spec</it>,
this method will expand or fill at each place holder by the value string
from <it>keys</it> with key equal to the name of the place holder.


If <it>keep</it> is zero, place holders with names not found in <it>keys</it>
will be replaced by empty string, namely, removing the place holders;
otherwise the are kept.

<demo dao>
tpl = 'The quick brown $(A) jumps over the lazy $(B)';
str = tpl.expand( { 'A' => 'fox', 'B' => 'dog' } );
stdio.println( str );
</demo>

<code dao>
string.expand( keys : tuple, spec='$', keep=1 ) => string
</code>
If the string contains place holders in form of <it>$(name)</it>,
where <it>$</it> is the special character passed in by <it>spec</it>,
this method will expand or fill at each place holder by the item value string
from <it>keys</it> with item field name equal to the name of the place holder.

If <it>keep</it> is zero, place holders with names not found in <it>keys</it>
will be replaced by empty string, namely, removing the place holders;
otherwise the are kept.

<demo dao>
tpl = 'The quick brown $(A) jumps over the lazy $(B)';
str = tpl.expand( ( A => 'fox', B => 'dog' ) );
stdio.println( str );
</demo>

<code dao>
string.resize( size : int )
</code>
Resize the string to have length <%></%>, and the extended part are filled with blank space.

<code dao>
string.size(  ) => int
</code>
Return the length of a string.

<code dao>
string.split( sep : string, quote="", rm=1 ) => list<string>
</code>
Split the string by seperator <%>sep</%>, and return the tokens as a list. 
Quotation symbols may also be specified to avoid breaking the string inside 
a pair of quotes. If the quotations symbols appear in the
begin and end of a token and <%>rm</%> is true, they are removed.
The seperators are not included in the result list.

<code dao>
string.tokenize( seps : string, quotes="", backslash=0 ) => list<string>
</code>
Tokenize the string by a set of separators. 
Each character in <%>seps</%> is treated as a separator.
Quotation symbols may also be specified to avoid breaking the string inside a pair of quotes.
If <%>backslash</%> is true, the separators and quotes preceded by a backslash are considered as normal characters.
The separators, quotes and backslashes are not removed from the result tokens.
If <%>simplify</%> is true, the blank spaces are removed from the beginning and end of
each token, and then empty tokens are remove from the resulting list.

<code dao>
string.tonumber( base=10 ) => double
</code>
Convert the string to a number with base equal to <%>base</%>.

<code dao>
string.tolower(  ) => string
</code>
Convert the string to lower case.
Return <%>self</%> string.

<code dao>
string.toupper(  ) => string
</code>
Convert the string to upper case.
Return <%>self</%> string.

<code dao>
string.encrypt( key : string, hex=0 ) => string
</code>
Encrypt the string with <%>key</%> using XXTEA algorithm.
If <%>hex</%> is true, store the encrypted string as hex digits.
Return <%>self</%> string.

<code dao>
string.decrypt( key : string, hex=0 ) => string
</code>
Decrypt the string with <%>key</%> using XXTEA algorithm.
If <%>hex</%> is true, the <%>self</%> string is interpreted as hex digits.
Return <%>self</%> string.

<=====>complex</=====>

<===>Method list:</===>
<code dao>
imag( v=0.00 ) => double
real( v=0.00 ) => double
</code>

<===>Method details:</===>
<code dao>
complex.imag( v=0.00 ) => double
</code>
If it is called with parameters, set the imaginary part of the complex.
No matter if it is called with or without parameters, 
return the imaginary part before modification.

<code dao>
complex.real( v=0.00 ) => double
</code>
If it is called with parameters, set the real part of the complex.
No matter if it is called with or without parameters, 
return the real part before modification.

<=====>list</=====>

<===>Method list:</===>

<code dao>
append( item : @ITEM )
clear(  )
dequeue(  )
enqueue( item : @ITEM )
erase( start=0, n=1 )
front(  ) => @ITEM
insert( item : @ITEM, pos=0 )
max(  ) => tuple<@ITEM,int>
min(  ) => tuple<@ITEM,int>
pop(  )
popback(  )
popfront(  )
push( item : @ITEM )
pushback( item : @ITEM )
pushfront( item : @ITEM )
resize( size : int )
size(  ) => int
ranka( k=0 ) => list<int>
rankd( k=0 ) => list<int>
sorta( k=0 ) => list<@ITEM>
sortd( k=0 ) => list<@ITEM>
sum(  ) => @ITEM
top(  ) => @ITEM
</code>

The <bf>sort()</bf> method that can take an expression as parameter
is now supported as a built-in method, please read <link>here=dao_functional_methods</link>.

<===>Method details:</===>
<code dao>
list<@ITEM>.append( item : @ITEM )
</code>
Append <%>item</%> to the list.

Here <*>@ITEM</*> indicates the <%>item</%> parameter will have the same type as the list,
so <%>append( item : @ITEM )</%> will only allow appending an item of the same type as the
type of items of the list.

<code dao>
list<@ITEM>.clear()
</code>
Remove all items from the list.

<code dao>
list<@ITEM>.dequeue()
</code>
Use the list as a queue, get the first item in the queue.

<code dao>
list<@ITEM>.enqueue( item : @ITEM )
</code>
Use the list as a queue, push <%>item</%> in the end of the queue.

<code dao>
list<@ITEM>.erase( start=0, n=1 )
</code>
Erase <%>n</%> items from the list starting from index <%>start</%>.

<code dao>
list<@ITEM>.front() => @ITEM
</code>
Get the first item in the front.

<code dao>
list<@ITEM>.insert( item : @ITEM, pos=0 )
</code>
Insert <%>item</%> at position <%>pos</%>.

<code dao>
list<@ITEM>.max(  ) => <@ITEM,int>
</code>
Return the max item and its index in the list. 

<code dao>
list<@ITEM>.min(  ) => <@ITEM,int>
</code>
Return the min item and its index in the list.

<code dao>
list<@ITEM>.pop(  )
</code>
Pop out one item from the end of the list.

<code dao>
list<@ITEM>.popback(  )
</code>
Pop out one item from the end of the list.

<code dao>
list<@ITEM>.popfront(  )
</code>
Pop out one item from the begin of the list.

<code dao>
list<@ITEM>.push( item : @ITEM )
</code>
Push <%>item</%> to the end of the list.

<code dao>
list<@ITEM>.pushback( item : @ITEM )
</code>
Push <%>item</%> to the end of the list.

<code dao>
list<@ITEM>.pushfront( item : @ITEM )
</code>
Push <%>item</%> to the begin of the list.

<code dao>
list<@ITEM>.ranka( k=0 ) => list<int>
list<@ITEM>.rankd( k=0 ) => list<int>
</code>
Ascending or descending ranking of the list.
If <it>k</it> is not zero, rank the smallest or largest <it>k</it> items.

<code dao>
list<@ITEM>.resize( size : int )
</code>
Resize the list to have size <%>size</%>. Extended part is filled with nil.

<code dao>
list<@ITEM>.size(  ) => int
</code>
Return the size of the list.

<code dao>
list<@ITEM>.sorta( k=0 ) => list<@ITEM>
list<@ITEM>.sortd( k=0 ) => list<@ITEM>
</code>
Ascending or descending sorting of the list.
If <it>k</it> is not zero, sort the smallest or largest <it>k</it> items.

<code dao>
list<@ITEM>.sum(  ) => @ITEM
</code>
Return the sum of the list. Only for lists contain numbers, strings or complex numbers.

<code dao>
list<@ITEM>.top(  ) => @ITEM
</code>
Get the last item in the list.

<=====>map</=====>

<===>Method list:</===>
<code dao>
clear(  )
erase( from : @KEY=nil, to : @KEY=nil )
find( key : @KEY, type=0 ) => tuple<int,@KEY,@VALUE>
insert( key : @KEY, value : @VALUE )
keys() => list<@KEY>
keys( from : @KEY ) => list<@KEY>
keys( from : @KEY, to : @KEY ) => list<@KEY>
size(  ) => int
values() => list<@VALUE>
values( from : @KEY ) => list<@VALUE>
values( from : @KEY, to : @KEY ) => list<@VALUE>
</code>

<===>Method details:</===>
<code dao>
map<@KEY,@VALUE>.clear(  )
</code>
Erase all the element pairs from the map.

<code dao>
map<@KEY,@VALUE>.erase( from : @KEY=nil, to : @KEY=nil )
</code>
Erase key-value pairs between key <%>from</%> and key <%>to</%> (inclusive).
If the second parameter is omited, erase the element with key equal to <%>from</%>.
If both parameters are omited, it will erase all elements.

<code dao>
map<@KEY,@VALUE>.find( key : @KEY, type=0 ) => tuple<int,@KEY,@VALUE>
</code>
If <%>type=0</%>, find the key equal to <%>key</%>;
If <%>type<0</%>, find the maximum key lesser than or equal to <%>key</%>;
If <%>type>0</%>, find the minimum key greater than or equal to <%>key</%>;
return a tuple of an integer, the key and value of the found element, 
the integer is 1 if found; 0, otherwise.

<code dao>
map<@KEY,@VALUE>.insert( key : @KEY, value : @VALUE )
</code>
Insert a pair of element.

<code dao>
keys() => list<@KEY>
keys( from : @KEY ) => list<@KEY>
keys( from : @KEY, to : @KEY ) => list<@KEY>
</code>
Return all keys, or keys starting from <it>from</it>,
or keys between <it>from</it> and <it>to</it>.

<code dao>
map<@KEY,@VALUE>.size(  ) => int
</code>
Return the number of elements in the map.

<code dao>
values() => list<@VALUE>
values( from : @KEY ) => list<@VALUE>
values( from : @KEY, to : @KEY ) => list<@VALUE>
</code>
Return all values, or values with keys starting from <it>from</it>,
or with keys between <it>from</it> and <it>to</it>.

<=====>numeric array</=====>

<===>Method list:</===>
<code dao>
dim(  ) => array<int>
dim( i : int ) => int
index( i : int ) => array<int>
size(  ) => int
resize( dims : array<int> )
reshape( dims : array<int> )
sorta( k=0 )
sortd( k=0 )
ranka( k=0 ) => array<int>
rankd( k=0 ) => array<int>
max( slice={} ) => tuple<@ITEM,int>
min( slice={} ) => tuple<@ITEM,int>
sum( slice={} ) => @ITEM
varn( slice={} ) => double
fft( inv=-1 )
</code>

The <bf>apply()</bf> method that can take an expression as parameter
is now supported as a built-in method, please read <link>here=dao_functional_methods</link>.
The <bf>noapply()</bf> method is removed.

<===>Method details:</===>

<code dao>
dim(  ) => array<int>
dim(  self : array<@ITEM> ) => array<int>
</code>
Return the sizes of each dimension as a vector.
<code dao>
array<@ITEM>.dim( i : int ) => int
</code>
Return the size of the i-th dimension of the array. 

<code dao>
array<@ITEM>.index( i : int ) => array<int>
</code>
Convert a flat index of the array to the corresponding multi-dimsional index.

<code dao>
array<@ITEM>.size(  ) => int
</code>
return the number of elements in the array.

<code dao>
array<@ITEM>.resize( dims : array<int> )
</code>
Resize the array to dimension as specified by <%>dims</%>.

<code dao>
array<@ITEM>.reshape( dims : array<int> )
</code>
Reshape the array to dimension as specified by <%>dims</%>.

<code dao>
array<@ITEM>.ranka( k=0 ) => array<int>
array<@ITEM>.rankd( k=0 ) => array<int>
</code>
Ascending or descending ranking of the array.
If <it>k</it> is not zero, rank the smallest or largest <it>k</it> items.

<code dao>
array<@ITEM>.sorta( k=0 )
array<@ITEM>.sortd( k=0 )
</code>
Ascending or descending sorting of the array.
If <it>k</it> is not zero, sort the smallest or largest <it>k</it> items.

<code dao>
array<@ITEM>.max( slice={} ) => tuple<@ITEM,int>
</code>
Return the max value and its flat index of the elements specified by <%>slice</%> as sub-array.
If <%>slice</%> is empty or omitted, return the max value of the array.
<demo dao>
mat = [ 1.5, 2.5, 3, 4; 5, 6, 7, 8; 9, 0, 1, 2 ];
stdio.println( mat.max( {  1:, 1:2 } ) );
</demo>
This example prints the maximum value and its index of the elements in a sub-matrix
formed by rows starting from the second row, and the second and third columns.

<code dao>
array<@ITEM>.min( slice={} ) => tuple<@ITEM,int>
</code>
Return the min value and its flat index of the elements specified by <%>slice</%>. 
If <%>slice</%> is empty or omitted, return the min value of the array.

<code dao>
array<@ITEM>.sum( slice={} ) => @ITEM
</code>
Return the sum value of the elements specified by <%>slice</%>. If <%>slice</%> is empty
or omitted, return the sum value of the array.

<code dao>
array<@ITEM>.varn( slice={} ) => double
</code>
Return the sample variance of the elements specified by <%>slice</%>. If <%>slice</%> is empty
or omitted, return the sample variance of the array.

<code dao>
array<complex>.fft( inv=-1 )
</code>
Fast Fourior Transform.

<=====>cdata</=====>

The <bf>cdata</bf>(previously named as <bf>buffer</bf>) data type represents a block of memory.

<===>Method list:</===>
<code dao>
cdata( size : int ) => cdata
copydata( buf : buffer )
getbyte( index : int, signed=1 ) => int
getdouble( index : int ) => double
getfloat( index : int ) => float
getint( index : int, signed=1 ) => int
getshort( index : int, signed=1 ) => int
getstring( mbs=1 ) => string
resize( size : int )
setbyte( index : int, value : int, signed=1 )
setdouble( index : int, value : double )
setfloat( index : int, value : float )
setint( index : int, value : int, signed=1 )
setshort( index : int, value : int, signed=1 )
setstring( string : string )
size(  ) => int
</code>

<===>Method details:</===>
<code dao>
buffer( size = 0 ) => buffer
</code>
Create a buffer of <%>size</%> bytes.

<code dao>
buffer.copydata( buf :buffer )
</code>
Copy data from buffer <%>buf</%>.
<code dao>
buffer.getbyte( index : int, signed=1 ) => int
</code>
Get one byte with specified <%>index</%>;
if <%>signed=1</%>, the byte is interpreted as signed.
<code dao>
buffer.getdouble( index : int ) => double
</code>
Get double floating number with specified <%>index</%>.
<code dao>
buffer.getfloat( index : int ) => float
</code>
Get single floating number with specified <%>index</%>.
<code dao>
buffer.getint( index : int, signed=1 ) => int
</code>
Get integer with specified <%>index</%>.
if <%>signed=1</%>, the integer is interpreted as signed.
<code dao>
buffer.getshort( index : int, signed=1 ) => int
</code>
Get short integer with specified <%>index</%>.
if <%>signed=1</%>, the short integer is interpreted as signed.
<code dao>
buffer.getstring( mbs=1 ) => string
</code>
Interprete the buffer as a string; Return MBS string if <%>mbs=1</%>, otherwise return WCS.
<code dao>
buffer.resize( size : int )
</code>
Resize the buffer to <%>size</%> bytes;
<code dao>
buffer.setbyte( index : int, value : int, signed=1 )
</code>
Set one byte specified <%>index</%> with <%>value</%>;
if <%>signed=1</%>, the byte is interpreted as signed.
<code dao>
buffer.setdouble( index : int, value : double, )
</code>
Set one double specified <%>index</%> with <%>value</%>;
<code dao>
buffer.setfloat( index : int, value : float )
</code>
Set one float specified <%>index</%> with <%>value</%>;
<code dao>
buffer.setint( index : int, value : int, signed=1 )
</code>
Set one integer specified <%>index</%> with <%>value</%>;
if <%>signed=1</%>, the integer is interpreted as signed.
<code dao>
buffer.setshort( index : int, value : int, signed=1 )
</code>
Set one short integer specified <%>index</%> with <%>value</%>;
if <%>signed=1</%>, the short integer is interpreted as signed.
<code dao>
buffer.setstring( string : string )
</code>
<code dao>
buffer.size(  ) => int
</code>
Return the size of the buffer in bytes.

<=====>std (was stdlib)</=====>

<===>Method list:</===>
<code dao>
stdlib.about( ... ) => string
stdlib.callable( object ) => int
stdlib.compile( source : string )
stdlib.copy( object : @OBJECT ) => @OBJECT
stdlib.ctimef( time=0, format='%Y-%M-%D, %H:%I:%S', namemap : map<string,list<string>> ={=>} ) => string
stdlib.ctime( time=0 ) => tuple<year:int,month:int,day:int,wday:int,hour:int,minute:int,second:int>
stdlib.debug( ... )
stdlib.error( info : string )
stdlib.eval( source : string, stream=stdio )
stdlib.exit( code=0 )
stdlib.gcmax( limit=0 ) => int
stdlib.gcmin( limit=0 ) => int
stdlib.listmeth( object )
stdlib.enable_fe( flags : int ) => int
stdlib.disable_fe( flags : int ) => int
stdlib.load( file : string )
stdlib.pack( number : int ) => string
stdlib.pack( list :list<int> ) => string
stdlib.sleep( seconds : float )
stdlib.system( command : string )
stdlib.time(  ) => int
stdlib.time( tm : tuple<year:int,month:int,day:int,wday:int,hour:int,minute:int,second:int> ) => int
stdlib.tokenize( source : string ) => list<string>
stdlib.unpack( string : string ) => list<int>
stdlib.warn( info : string )
</code>

<===>Method details:</===>
<code dao>
about( ... ) => string
</code>
Return the type name and address of the parameters.
<code dao>
callable( object ) => int
</code>
Tell if the object is callable.
<code dao>
compile( source : string )
</code>
Compile the source code and return a routine object.
<code dao>
copy( object : @OBJECT ) => @OBJECT
</code>
Return a deep copy of the object.
(TODO: the implementation might be incomplete.)

<code dao>
ctime( time=0 ) => tuple<year:int,month:int,day:int,wday:int,hour:int,minute:int,second:int>
</code>
Convert <%>time</%> returned from <*>stdlib.time()</*> into calendar time as a tuple.

<code dao>
ctimef( time=0, format='%Y-%M-%D, %H:%I:%S', namemap : map<string,list<string>> ={=>} ) => string
</code>
Convert <%>time</%> returned from <*>stdlib.time()</*> into calendar time with
specified <%>format</%>; the names for year, month and date etc. can be specified
in <%>namemap</%>
<code dao>
debug( ... )
</code>
If called with parameters, return the type name and address of the parameters.
If called without parameters, the debugging console will be prompted up.
It only has effects in debugging running mode.
<code dao>
error( info : string )
</code>
Print <%>info</%> as error information and abort current virtual machine process.
<code dao>
eval( source : string, stream=stdio )
</code>
Evaluate the source, and use <%>stream</%> as the standard IO device.
<code dao>
exit( code=0 )
</code>
Exit with <%>code</%>.
<code dao>
gcmax( limit=0 ) => int
</code>
Return the current maximum GC threshold.
If there is the parameter, the threshold is changed to <%>limit</%>.
The maximum GC threshold is the upper bound of number of candidate garbage objects,
if this limit is exceeded, all the mutator threads are blocked until their are waked up
by the garbage collector after finishing to precess a certain part of the garbages.
Normally, the garbage collection thread runs concurrently with the mutator threads,
or is blocked if there are too few garbage.
<code dao>
gcmin( limit=0 ) => int
</code>
Return the current minimum GC threshold.
If there is the parameter, the threshold is changed to <%>limit</%>.
The minimum GC threshold is the lower bound of number of candidate garbage objects
for the garbage collector to wake up and start garbage collecting.
<code dao>
listmeth( object )
</code>
List the available methods for the object.
<code dao>
load( file : string )
</code>
Load and execute scripts from a file.
<code dao>
pack( number : int ) => string
</code>
Convert the number into a character.
<code dao>
pack( list :list<int> ) => string
</code>
Convert the list of numbers into a string.
<code dao>
sleep( seconds : float )
</code>
Let the current thread to sleep for <%>seconds</%>(may lesser than 1) seconds.
<code dao>
system( command : string )
</code>
Run a system command.
<code dao>
time(  ) => int
</code>
Return current time.
<code dao>
time( tm : tuple<year:int,month:int,day:int,wday:int,hour:int,minute:int,second:int> ) => int
</code>
Convert calendar time to time in seconds (as returned by time()).
<code dao>
tokenize( source : string ) => list<string>
</code>
Tokenize Dao source code.
<code dao>
unpack( string : string ) => list<int>
</code>
Unpack string into a list of number.
<code dao>
warn( info : string )
</code>
Print a warning, with file name and line number information.

<=====>stream and io (was stdio) library</=====>

<===>Method list:</===>
<code dao>
close(  )
eof(  )
flush(  )
getstring(  )
isopen(  )
name(  )
open(  )
open( file : string, mode : string )
popen( cmd : string, mode : string )
write( ... )
writeln( ... )
writef( format : string, ... )
print( ... )
println( ... )
printf( format : string, ... )
read( count=0 )=>string
read( file : string )=>string
seek( pos : int, from : int )
sstream( mbs=1 )
tell(  )
</code>

<===>Method details:</===>
<code dao>
close(  )
</code>
Close a file stream.

<code dao>
eof(  )
</code>
Check if the end of the stream is reached.

<code dao>
flush(  )
</code>
Flush the stream to cause all buffered output to be written to the device.

<code dao>
getstring(  )
</code>
Get output string from a string stream.

<code dao>
isopen(  )
</code>
Check if a file stream is open.

<code dao>
name(  )
</code>
Get the file name of a file stream

<code dao>
open(  )
</code>
Open a temporary file stream.

<code dao>
open( file : string, mode : string )
</code>
Open a file stream on <%>file</%> with mode <%>mode</%>.
The supported mode is exactly the same as what is supported in standard C function <%>fopen()</%>.

<code dao>
popen( cmd : string, mode : string )
</code>
Open a pipe in mode <it>mode</it> to execute command <it>cmd</it>.

<code dao>
write( ... )
print( ... )
</code>
Print to the stream.

<code dao>
writeln( ... )
println( ... )
</code>
Print to the stream with a line break symbol.

<code dao>
writef( format : string, ... )
printf( format : string, ... )
</code>
Formated printing, <%>format</%> can be specified in the same way as in C.

<code dao>
read( count=0 )=>string
read( file : string )=>string
</code>
If <it>count</it> is positive, read <it>count</it> number of bytes from the stream;
if <it>count</it> is negative, read all bytes from the stream;
otherwise, read one line from the stream including the line break symbol.

<code dao>
read( file : string )=>string
</code>
Read the whole file from <it>file</it>.

<code dao>
seek( pos : int, from : int )
</code>
Seek stream position with offset <%>pos</%> from <%>from</%>;
<%>from</%> can be "stdio.SEEK_CUR", "stdio.SEEK_SET" or "stdio.SEEK_END";

<code dao>
sstream( mbs=1 )
</code>
Create a string stream; the internal string buffer can be MBS or WCS depends on parameter <%>mbs</%>.

<code dao>
tell(  )
</code>
Tell the current stream position.

<=====>math</=====>

These math functions except <bf>srand()</bf> and <bf>pow()</bf>,
they are also supported as builtin functions since Dao 1.1.

<===>Method list:</===>
<code dao>
math.abs( p : double )
</code>
<code dao>
math.abs( p : complex )
</code>
<code dao>
math.acos( p : double )
</code>
<code dao>
math.arg( p : complex )
</code>
<code dao>
math.asin( p : double )
</code>
<code dao>
math.atan( p : double )
</code>
<code dao>
math.ceil( p : double )
</code>
<code dao>
math.ceil( p : complex )
</code>
<code dao>
math.cos( p : double )
</code>
<code dao>
math.cos( p : complex )
</code>
<code dao>
math.cosh( p : double )
</code>
<code dao>
math.cosh( p : complex )
</code>
<code dao>
math.exp( p : double )
</code>
<code dao>
math.exp( p : complex )
</code>
<code dao>
math.floor( p : double )
</code>
<code dao>
math.floor( p : complex )
</code>
<code dao>
math.imag( p : complex )
</code>
<code dao>
math.log( p : double )
</code>
<code dao>
math.log( p : complex )
</code>
<code dao>
math.norm( p : complex )
</code>
<code dao>
math.pow( p1 : double, p2 : double )
</code>
<code dao>
math.pow( p1 : double, p2 : complex )
</code>
<code dao>
math.pow( p1 : complex, p2 : double )
</code>
<code dao>
math.pow( p1 : complex, p2 : complex )
</code>
<code dao>
math.real( p : complex )
</code>
<code dao>
math.sin( p : double )
</code>
<code dao>
math.sin( p : complex )
</code>
<code dao>
math.sinh( p : double )
</code>
<code dao>
math.sinh( p : complex )
</code>
<code dao>
math.sqrt( p : double )
</code>
<code dao>
math.sqrt( p : complex )
</code>
<code dao>
math.srand( p : double )
</code>
<code dao>
math.rand( p : double )
</code>
<code dao>
math.tan( p : double )
</code>
<code dao>
math.tan( p : complex )
</code>
<code dao>
math.tanh( p : double )
</code>
<code dao>
math.tanh( p : complex )
</code>

<=====>reflection</=====>

<===>Method list:</===>
<code dao>
namespace( object=nil ) => any
name( object ) => string
type( object ) => any
base( object ) => list<any>
doc( object, newdoc='' ) => string
constant( object, restrict=0 )=>map<string,tuple<value:any,type:any> >
variable( object, restrict=0 )=>map<string,tuple<value:any,type:any> >
constant( object, name:string, value=nil )=>tuple<value:any,type:any>
variable( object, name:string, value=nil )=>tuple<value:any,type:any>
class( object ) => any
routine() => any
routine( rout : any ) => list<any>
param( rout )=>list<tuple<name:string,type:any,deft:int,value:any> >
isa( object, name : string ) => int
isa( object, type : any ) => int
self( object ) => any
argc() => int
argv() => list<any>
argv( i : int ) => any
</code>

<===>Method details:</===>
<code dao>
namespace( object=nil ) => any
</code>
If object is a routine or class, return the namespace where it is defined;
otherwise, return the current namespace.

<code dao>
name( object ) => string
</code>
Get the name of a routine, function, method or class.

<code dao>
type( object ) => any
</code>
return the type of the object.

<code dao>
base( object ) => list<any>
</code>
If <%>object</%> is a class, return its direct parent classes;
If <%>object</%> is a class instance, return its direct parent instances;

<code dao>
doc( object, newdoc='' ) => string
</code>
return the documentation string of a routine or class;
if "newdoc" is passed, set the documentation string to "newdoc";

<code dao>
constant( object, restrict=0 )=>map<string,tuple<value:any,type:any> >
</code>
Return the constant fields of object, if "restrict" is not zero and
there are private or protected fields in "object", only return the public ones.
The return value is a map, mapping from field name and field value and type.

<code dao>
variable( object, restrict=0 )=>map<string,tuple<value:any,type:any> >
</code>
Return the variable fields of object, if "restrict" is not zero and
there are private or protected fields in "object", only return the public ones.
The return value is a map, mapping from field name and field value and type.

<code dao>
constant( object, name:string, value=nil )=>tuple<value:any,type:any>
</code>
Return a tuple of value and type for constant field "name" in object.
If "value" is passed in, set the field value to "value".
All field can be accessed and modified by this function.

<code dao>
variable( object, name:string, value=nil )=>tuple<value:any,type:any>
</code>
Return a tuple of value and type for variable field "name" in object.
If "value" is passed in, set the field value to "value".
All field can be accessed and modified by this function.

<code dao>
class( object ) => any
</code>
If <%>object</%> is a routine, return its host class which defines this routine as a method;
If <%>object</%> is a class instance, return its class prototype.

<code dao>
routine() => any
</code>
return the current routine that is running.

<code dao>
routine( rout : any ) => list<any>
</code>
return the list of overloaded routines with the same name as routine "rout".

<code dao>
param( rout )=>list<tuple<name:string,type:any,deft:int,value:any> >
</code>
return the parameter list of "rout".
The returned list contains tuples composed of parameter name, type, and default value.
The "value" field is set to nil, if the parameter has no default value.
The "deft" field of the tuples indicates whether the "value" is a default value or not, 
in case that a nil value is set as default.

<code dao>
isa( object, name : string ) => int
</code>
Check if object is of type indicated by <%>name</%>.
Normally <%>name</%> should be a valid type name such as
<bf>int</bf>, <bf>float</bf>, <bf>list<int></bf> or a class name etc.
It can also be one of the name listed in the following table,
to check if <%>object</%> is in a category of certain types. For example,
when "class" is passed as <%>name</%>, <%>isa()</%> will return true,
if <%>object</%> is a class.
<table>
^ name ^ type ^
| class | a class |
| object | a class instance |
| routine | a Dao routine |
| function | a C function |
| namespace | a namespace |
| tuple | a tuple |
| list | a list |
| map | a map |
| array | an array |
</table>

<code dao>
isa( object, type : any ) => int
</code>
Check if <%>object</%> is of type <%>type</%>, which is a type object
that can be returned by <%>reflect.type()</%>.

<code dao>
argc() => int
</code>
Return the argument count of the current function call.

<code dao>
argv() => list<any>
</code>
Return the argument values as a list of the current function call.

<code dao>
argv( i : int ) => any
</code>
Return the i-th argument value of the current function call.

<code dao>
self( object )
</code>
Return the mapping-down class instance of the class instance <%>object</%>

<code dao>
trace(  )
</code>
Print the trace of calling stack.

<=====>coroutine</=====>

<===>Method list:</===>
<code dao>
coroutine.create( object, ... )
coroutine.resume( object, ... )
coroutine.status( object )
coroutine.yield( ... )
</code>

<===>Method details:</===>
<code dao>
create( object, ... )
</code>
Create a coroutine object which is actually a virtual machine process with its own calling stack
of contexts. <%>object</%> must be a routine or context (function closure);
The addition parameters will be passed to the created coroutine object
in the same way as normal function call.
The coroutine object is created in suspending status, and should be executed by calling
<*>coroutine.resume()</*>.

Create coroutine with wrong parameters will raise an exception.

<code dao>
resume( object, ... )
</code>
Resume the coroutine object.
The additional parameters to <*>resume()</*> will become results from <*>yield()</*>.

Resuming a coroutine that has reach its end will raise an exception.

<code dao>
status( object )
</code>
Return the status of the coroutine object as a string, which can be one of
<table>
| suspended | running | aborted | finished | not_a_coroutine |
</table>

<code dao>
yield( ... )
</code>
Yield current coroutine execution. Any parameters in <*>yield</*> will become the result from
<*>resume()</*>.

<=====>multi-threading library</=====>

The multi-threading library in Dao is provided by the library object "mtlib".


<===>Method list:</===>
<code dao>
mtlib.thread( object, ... ) => thread
mtlib.mutex(  ) => mutex
mtlib.condition(  ) => condition
mtlib.semaphore(  ) => semaphore
mtlib.exit(  )
mtlib.mydata(  ) => map<string,any>
mtlib.self(  ) => thread
mtlib.testcancel(  )
</code>

<===>Method details:</===>
<code dao>
condition(  ) => condition
</code>
Create a condition variable.

<code dao>
thread( object, ... )
</code>
Create a thread object. <%>object</%> must be a Dao routine or context, which will receive
parameters from the additional part of the parameters for <*>thread.create()</*>.

<code dao>
exit(  )
</code>
Exit current thread.

<code dao>
mutex(  ) => mutex
</code>
Create a mutex.

<code dao>
mydata(  ) => map<string,any>
</code>
Get thread specific data as a map.

<code dao>
self(  ) => thread
</code>
Return the current thread object.
<comment>
Return nil object for the main thread.
</comment>

<code dao>
semaphore(  ) => semaphore
</code>
Create a semaphore object.

<code dao>
testcancel(  )
</code>
Create a cancel point. If <*>cancel()</*> is called before this point, calling this function
will terminate the current thread.

<=====>thread object</=====>

<===>Method list:</===>
<code dao>
cancel(  )
detach(  )
join(  )
mydata(  ) => map<string,any>
</code>

<===>Method details:</===>
<code dao>
cancel(  )
</code>
Cancel the execution of the thread object.

<code dao>
detach(  )
</code>
Detach the execution of the thread object.

<code dao>
join(  )
</code>
Join the execution of the thread object with the current thread.

<code dao>
mydata(  ) => map<string,any>
</code>
Get thread specific data as a map.

<=====>mutex</=====>

<===>Method list:</===>
<code dao>
lock(  )
trylock(  )
unlock(  )
</code>

<===>Method details:</===>
<code dao>
lock(  )
</code>
Lock the mutext.

<code dao>
trylock(  )
</code>
Try to locke the mutex. Return true if successful, otherwise, false.

<code dao>
unlock(  )
</code>
Unlock the mutex.

<=====>condition variable</=====>

<===>Method list:</===>
<code dao>
broadcast(  )
signal(  )
timedwait( mtx : mutex, seconds : float )
wait( mtx : mutex )
</code>

<code dao>
broadcast(  )
</code>
Wake all threads blocked on the condition variable.

<code dao>
signal(  )
</code>
Wake one thread(randomly) blocked on the condition variable.

<code dao>
timedwait( mtx : mutex, seconds : float )
</code>
Block the current thread on the condition variable with timeout, which can be a decimal number.

<code dao>
wait( mtx : mutex )
</code>
Block the current thread on the condition variable.

<=====>semaphore</=====>

<===>Method list:</===>
<code dao>
getvalue(  )
post(  )
setvalue( n : int )
wait(  )
</code>

<===>Method details:</===>
<code dao>
getvalue(  )
</code>
Get the available resource count of the semaphore.

<code dao>
post(  )
</code>
Release one resource of the semaphore.

<code dao>
setvalue( n : int )
</code>
Set the total number of resource of the semaphore.

<code dao>
wait(  )
</code>
Require one resource of the semaphore. The current thread will be blocked if the resource is
not available.

<=====>network</=====>

<===>Method list:</===>
<code dao>
network.FD_CLR( fd : int, set :fd_set )
network.FD_ISSET( fd : int, set :fd_set )
network.FD_SET( fd : int, set :fd_set )
network.FD_ZERO( set :fd_set )
network.accept( socket : int )
network.bind( port : int )
network.close( socket : int )
network.connect( host : string, port : int )
network.gethost( host : string )
network.getpeername( socket : int )
network.listen( socket : int, backlog =10 )
network.receive( socket : int, maxlen =1000 )
network.receive_dao( socket : int )
network.select( nfd : int, setr :fd_set, setr :fd_set, setr :fd_set, tv : float )
network.send( socket : int, data : string )
network.send_dao( socket : int, ... )
</code>
<===>Network File Description Set Handling</===>
File description set can be created by: <%>fd_set()</%>
<code dao>
FD_CLR( fd : int, set :fd_set )
</code>
Remove <%>fd</%> from <%>set</%>.
<code dao>
FD_ISSET( fd : int, set :fd_set )
</code>
Check if <%>fd</%> is in <%>set</%>.
<code dao>
FD_SET( fd : int, set :fd_set )
</code>
Add <%>fd</%> to <%>set</%>.
<code dao>
FD_ZERO( set :fd_set )
</code>
Clear the set.

<===>Method details:</===>
<code dao>
accept( socket : int )
</code>
Accept a connection from the socket.
<code dao>
bind( port : int )
</code>
Bind to the port.
<code dao>
close( socket : int )
</code>
<code dao>
connect( host : string, port : int )
</code>
Connect to <%>host</%> through <%>port</%>.
<code dao>
gethost( host : string )
</code>
Get host information (names and addresses).
<code dao>
getpeername( socket : int )
</code>
Get peer information.
<code dao>
listen( socket : int, backlog =10 )
</code>
Listen to the socket.
<code dao>
receive( socket : int, maxlen =1000 )
</code>
Receive raw data from the socket.
<code dao>
receive_dao( socket : int )
</code>
Receive data from the socket, and create and return proper Dao data.
It should be used in pair with <%>send_dao()</%>.
<code dao>
select( nfd : int, setr :fd_set, setw :fd_set, sete :fd_set, tv : float )
</code>
Quoted from glibc documentation:

<table>
The select function blocks the calling process until there is activity on any of the specified sets of file descriptors, or until the timeout period has expired.

The file descriptors specified by the read-fds argument are checked to see if they are ready for reading; the write-fds file descriptors are checked to see if they are ready for writing; and the except-fds file descriptors are checked for exceptional conditions. You can pass a null pointer for any of these arguments if you are not interested in checking for that kind of condition.

A file descriptor is considered ready for reading if it is not at end of file. A server socket is considered ready for reading if there is a pending connection which can be accepted with accept; see section Accepting Connections. A client socket is ready for writing when its connection is fully established; see section Making a Connection.
</table>

<code dao>
send( socket : int, data : string )
</code>
Send raw data to the socket.
<code dao>
send_dao( socket : int, ... )
</code>
Send Dao data to the socket, with data type information attached to the network packets.

<=====>message passing interface</=====>

<===>Method list:</===>
<code dao>
mpi.receive( timeout=-1.0 )
mpi.receive( pid : string, timeout=-1.0 )
mpi.send( object, ... )
mpi.spawn( pid : string, proc : string, timeout=-1.0, ... )
</code>

<===>Method details:</===>
<code dao>
receive( timeout=-1.0 )
</code>
Receive message with timeout. No possitive timeout means infinite waiting.
Return a list of received data.
<code dao>
receive( pid : string, timeout=-1.0 )
</code>
Receive message from process <%>pid</%> with timeout.
<code dao>
send( object, ... )
</code>
If <%>object</%> is a process, send the rest of parameters as message to it;
If <%>object</%> is a callable object, this object is scheduled to be called asynchronously
with the rest parameters.
<code dao>
spawn( pid : string, proc : string, ... )
</code>
Spawn a virtual machine(VM) or operation system(OS) process.
If a OS process or a VM process wthin another OS process is not spawned
successfully within the timeout, an exception will be raised.
Return a process handle if it created a local (within the same OS process)
VM process.
<%>pid</%> must be one of the form in the following table:
<table>
^pid ^proc^the rest parameters ^meaning
|""|routine name|parameters for the routine|VM process without name, accessable within the same OS process by its handle|
|"vm_proc"|as above|as above|named VM process, globally accessable by different OS processes on different computers|
|"@os_proc"|Dao script file name|timeout (default -1.0)|named OS process, globally accessable |
|"vm_proc@os_proc"|as "vm_proc"|as "vm_proc"|named VM process within a OS process named "os_proc", globally accessable|
|"@os_proc@@host"|Dao script file name|timeout (default -1.0)|named OS process on network "host", globally accessable |
|"vm_proc@os_proc@@host"|as "vm_proc"|as "vm_proc"|named VM process within a OS process named "os_proc@@host", globally accessable|
</table>
