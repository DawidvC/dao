load help

@[name]
dao.defer-error
@[name]

@[title]
延迟代码块和错误处理
@[title]


@[text]


道语言里的错误处理是基于延迟代码块(defer blocks)。
延迟代码块可基于错误或例外有条件或无条件执行。


@[subsection]
延迟代码块(Defer Blocks)
@[subsection]

延迟代码块是一种在函数正常退出或因错误退出时执行的代码块。
延迟代码块的有条件或无条件执行是基于有无错误和什么错误：
@[list]
-- @[code]defer{block}@[code] or @[code]defer(){block}@[code]: 无条件执行，
   不管函数以何种形式退出；

-- @[code]defer(none){block}@[code]: 有条件执行，仅当函数正常退出时；

-- @[code]defer(any){block}@[code]: 有条件执行，当函数因任何错误退出时；

-- @[code]defer(type){block}@[code]: 有条件执行，
   仅当导致函数退出的错误跟@[code]type@[code]匹配时；

-- @[code]defer(type as name){block}@[code]: 跟@[code]defer(type){block}@[code]一样，
   并且在代码块里，错误对象将可以用变量名@[code]name@[code]访问。
@[list]

无条件延迟代码块的最主要用途是函数退出时的善后处理。
这种善后处理将被无条件地执行，而不管函数是以何种方式退出。
无错误条件延迟代码块@[code]defer(none)@[code]，则可用于实现原子事务处理。
其他错误条件延迟代码块则主要用于错误处理。


延迟代码块是以函数闭包编译和执行的。也就是说这种代码块可以访问外层局部变量，
将在运行时生成可获得这些变量当前值的闭包。只不过这些闭包将在函数退出是自动
执行。所有可执行延迟代码块将以被创建顺序的相反顺序执行。

@[code]
routine Test()
{
	defer {
		io.writeln( "always executed" )
	}
	defer( none ){
		io.writeln( "defer( none )" )
	}

	for( i = 2 : 5 ) defer { io.writeln( "deferred", i ) }

	io.writeln( "returning" );
	return 123
}

io.writeln( Test() )
@[code]



@[subsection]
错误处理
@[subsection]


道里面错误处理的主要方式是基于有条件的延迟代码块。
一个函数里可为不同的错误类型定义不同的延迟代码块。
每个有条件的延迟代码块只能被一个错误对象激活运行。
当有多个错误时，每个代码块将从最新的错误到最老的错
误检查是否可被其中的一个错误激活。


为了处理某个特定的错误类型，那么一个以该类型为条件参数的
延迟代码块必须被定义。这样这个代码块将可以被该类型的错误
激活运行。并且激活此代码块的错误将被消除，允许程序再从处理
错误的函数的调用处继续执行。


这种处理错误的延迟代码块的返回值类型必须跟定义它的函数一致。
因为当这种延迟代码块被执行时，该函数还没执行到正常返回，
所以返回值还没设定。这种延迟代码块是唯一可以在错误发生后
设定合适的返回值的地方。


例子：
@[code]
routine Test()
{
	defer ( Error ){
		io.writeln( "Error is handled! And a new value is returned!" )
		return 456
	}
	io.writeln( "Test(): before error;" )
	std.error( "some error" )
	io.writeln( "Test(): after error;" )
	return 123
}
io.writeln( Test() )
@[code]
这里使用了标准方法@[code]std.error()@[code]来抛出错误。
这个方法有三个重载版本，这里用的是最简单的一个。
它将以它的参数字符串为错误信息创建一个通用错误对象。
道定义一些标准的错误类型以报告一些标准操作和方法所可能抛出的错误。



@[subsection]
错误类型
@[subsection]

上例所用@[code]Error@[code]类型是一个通用错误类型。它也是其他错误类型的基类。
@[code]Error@[code]类型本身则是从例外类型@[code]Exception@[code]派生出来。
这个例外类型可保存所有跟它相关的信息，诸如，错误的通用名，错误消息，错误数据，
源文件名，行号和函数调用栈等。


以下是标准的道例外类型：
@[code]
Exception                # General exception
Warning                  # General warning
Error                    # General error
Error::Field             # Invalid field
Error::Field::NotExist   # Field not exist
Error::Field::NotPermit  # Field not permit
Error::Float             # Floating point error
Error::Float::DivByZero  # Division by zero
Error::Float::OverFlow   # Floating point overflow
Error::Float::UnderFlow  # Floating point underflow
Error::Index             # Invalid index
Error::Index::Range      # Index out of range
Error::Key               # Invalid key
Error::Key::NotExist     # Key not exist
Error::Param             # Invalid parameter(s)
Error::Syntax            # Invalid syntax
Error::Type              # Invalid type
Error::Value             # Invalid value
Error::File              # File error
@[code]
Note that, @[code]Warning@[code] and @[code]Error@[code] are also registered
in the global scope, so they can be directly used without @[code]Exception::@[code] scoping.
Among these exception types, only @[code]Exception@[code], @[code]Warning@[code]
and @[code]Error@[code] are @[green]pre-defined@[green], and the rest are only
@[green]pre-declared@[green].
Only the pre-defined exception types can be directly used in Dao code.
Other error types need to be explicitly defined using the @[code]Exception::Define()@[code]
method in the following way,
@[code]
const IndexError  = Exception::Define( "Error::Index" )
@[code]
This is a constant expression which will be evaluated during parsing
so that the defined type can be used right after this line of code.
The evaluation of this method call will create a new error type named @[code]Index@[code]
that is derived from @[code]Error@[code].
This new error type will be created a C data type and scoped / registered
inside the @[code]Error@[code] type.
The scoped name passed to the @[code]Exception::Define()@[code] as the first parameter
will serve as a unique string ID for the new error type, and the future error type definition
using the same string will return the same error type.


Cutomized error type can be defined either by defining a Dao class that is derived from
the @[code]Error@[code] type, or by defining a C type using the above method,
@[code]
const MyErrorType = Exception::Define( "Error::MyError", "General information" )
@[code]
Here the second parameter is the general information that is associated to the error type.
Defining pre-declared error types need no such parameter, as it will be set internally.
Defining a new error type this way as a C data type has the advantage of convenience
and implicity.


Now the newly defined error type can be used in two ways, by either using the new
constant value retuned by @[code]Exception::Define()@[code], or by using the cannonical
name @[code]Error::MyError@[code],
@[code]
defer( MyErrorType ) { ... }
defer( Error::MyError ) { ... }
@[code]


Here is another example of defining a new error type by subclassing from @[code]Error@[code],
@[code]
class MyError : Error
{
	routine serialize(){ return ('MyError', self) }
}
@[code]




@[subsection]
Raising Warning and Error
@[subsection]

In Dao code, a warning can be raised simply with the standard method
@[code]std.warning()@[code],
@[code]
std.warn( info: string )
@[code]
This will print the warning message right away along with file name and file number
where the warning is issued. It also prints the call stack trace for this call
to provide some information about the context where the warning happens.


An error can be similarily raised with the standard method
@[code]std.error()@[code],
@[code]
std.error( info: string )
@[code]
In Dao, raising an error will cause the current routine to exit immediately,
and to start to execute the defer blocks if the routine has created any.
If one of the defer blocks has handled the error, the execution will be
resume in its caller. Otherwise its caller will also exit with extra
execution of its defer blocks as well. This will be repeated until
either the error is handled and the normal execution is resumed,
or there is no more caller. In this case, the error will be printed
with a list of call trace including function names, file names and line numbers.


There are three variants of the standard error method.
The above one is the first and simplest one.
The other two are the following:
@[code]
std.error( errorObject: Error )
std.error( errorType: class<Error>, info: string, data: any = none )
@[code]
The former will allow raising a pre-created error object.
The second will create an error on-the-fly as an instance of the error type
@[code]errorType@[code] with message @[code]info@[code] and data @[code]data@[code].



@[subsection]
Methods Related to Error Handling
@[subsection]

There are three standard methods that are related to error handling.
@[code]
std.exec() [=>@T] => @T
std.exec( defaultValue: @T ) [=>@T] => @T
std.try() [=>@T] => list<Error>|Error|@T
@[code]


@[subsubsection]
std.exec()[=>@T]=>@T
@[subsubsection]


As mentioned above, the normal execution will be resumed by
the caller of the function that handles the exceptions in its defer blocks.
In order to resume the normal execution right after handling of exceptions,
a special type of code blocks can be used to "host" the defer blocks,
@[code(dao)]
std.exec() [=>@T] => @T
@[code(dao)]
Since code sections are executed in new stack frames.
Handling errors inside such code section will allow the program
to resume right after the code section calls.

@[code(dao)]
fout = io::stdio

std.exec {
	defer { recover() }
	fout = io.open( "NonExistentFile.txt", 'r+' )
}

if( fout != io::stdio ) defer{ fout.close() }

fout.writeln( 'hello' )
@[code(dao)]


@[subsubsection]
std.exec(defaultValue:@T)[=>@T]=>@T
@[subsubsection]

This method can be used whenever an expression or a block of code may either suceed
and return the result, or fail and return a pre-defined default value.
The passed in @[code]defaultValue@[code] will be returned only if the code section
fails with exception. And in such case, the exception will be surpressed automatically.
This method will allow simplifying the above example into the following,
@[code(dao)]
fout = std.exec( io::stdio ){ io.open( "NonExistentFile.txt", 'r+' ) }
if( fout != io::stdio ) defer{ fout.close() }
fout.writeln( 'hello' )
@[code(dao)]



@[subsubsection]
std.try()[=>@T]=>list<Error>|Error|@T
@[subsubsection]

This method is similar to the above one, but instead of returning a predefined default value,
it will return the error object(s) if the code section failed with error(s).


@[text]
