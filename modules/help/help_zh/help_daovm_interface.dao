load help;

@[name]
daovm.interface
@[name]

@[title]
使用Dao的C语言接口编程
@[title]
load help;


################################################################################
################################################################################
#### Embedding Dao Virtual Machine
################################################################################
################################################################################
@[name]
daovm.interface.embedding
@[name]

@[title]
嵌入道虚拟机
@[title]

@[text]

@[section]
一个简单的例子
@[section]

@[subsection]
初始化道运行环境
@[subsection]

在使用道库做任何事之前，@[green]DaoInit()@[green]必须被调用以初始化道运行环境。

@[code(cxx)]
// 初始化道:
DaoVmSpace *vmspace = DaoInit( NULL );
@[code(cxx)]
这个函数将返回一@[green]DaoVmSpace@[green]对象，该对象可用来载入道脚本或模块。
此函数可以接受一@[cyan]char*@[cyan]字符串参数，传入的此参数应当是此程序的路径
和名称，用来确定额外的模块搜寻路径。

@[comment]
Before you start to use the @[green]DaoVmSpace@[green] object
to run Dao scripts or load Dao modules, you may set some options
in the object, e.g:
@[code(cxx)]
DaoVmSpace_SetOptions( vmspace, DAO_EXEC_DEBUG );
@[code(cxx)]
@[comment]

@[subsection]
载入脚本文件
@[subsection]

一旦你有了一个@[green]DaoVmSpace@[green]对象，你可以开始运行道脚本或载入道模块了。
如果你有一个主脚本文件，并且你所要做的仅仅是执行这个文件，你可以简单地调用：
@[code(cxx)]
// 载入并执行 "myscript.dao":
DaoVmSpace_Load( vmspace, "myscript.dao" );
@[code(cxx)]
顶层作用域的代码将被执行。

@[subsection]
退出道环境
@[subsection]

在你用完道虚拟机后，你可以调用以下函数来正确地终止道虚拟机并退出道环境。
调用这个这个函数将会等待未完成的线程结束，也会等待垃圾回收器回收完垃圾对象，
并且释放一些内部数据结构等。
@[code(cxx)]
// 退出 Dao:
DaoQuit();
@[code(cxx)]

@[subsection]
将这些代码放在一起
@[subsection]

将这些代码放在一起，嵌入道就如下面的例子简单：
@[code(cxx)]
// 初始化 Dao:
DaoVmSpace *vmspace = DaoInit( NULL );
// 载入运行 "myscript.dao":
DaoVmSpace_Load( vmspace, "myscript.dao" );
// 退出 Dao:
DaoQuit();
@[code(cxx)]


@[section]
一个稍微高级点的例子
@[section]

在道里，每个代码文件在编译后都会被表示为一个命名空间对象，
它存有这个文件里的和一些它载入的文件里的全局常量和变量等。
要做任何实际的事情，你一般都要用到这个命名空间对象。


@[subsection]
获得命名空间对象
@[subsection]

接着上面的例子，如果你想要调用"myscript.dao"里的某个函数，
你可以先保存DaoVmSpace_Load()所返回的命名空间对象：
@[code(cxx)]
// 载入 "myscript.dao" 并获得命名空间对象:
DaoNamespace *nspace = DaoVmSpace_Load( vmspace, "myscript.dao" );
@[code(cxx)]


@[subsection]
获取函数对象
@[subsection]

要找到你想调用的函数，使用如下代码：
@[code(cxx)]
// 查找名为 "myfunction" 的对象:
DaoValue *value = DaoNamespace_FindData( nspace, "myfunction" );
// 尝试将它转换为函数对象:
DaoRoutine *myfunc = DaoValue_CastRoutine( value );
@[code(cxx)]
如果"myfunction"确实是个函数对象，@[cyan]myfunc@[cyan]将不会是空指针。


@[subsection]
获得虚拟机进程对象
@[subsection]

道程序都是以虚拟机进程的方式在道虚拟机上运行。
因此若要调用前面的函数，你将需要一个虚拟机进程对象@[green]DaoProcess@[green]。
这种对象可由直接调用@[green]DaoProcess_New()@[green]生成，
但是更好的方式是从@[green]DaoVmSpace@[green]对象获得，
这种方式更经济，更方便管理。
@[code(cxx)]
// 获得虚拟机进程对象:
DaoProcess *proc = DaoVmSpace_AcquireProcess( vmspace );
@[code(cxx)]

@[subsection]
准备参数值
@[subsection]

现在假定函数"myfunction"需要一个整数作为第一个参数和一个字符串作为第二个参数。
为了调用它，我们将需要先准备好一个道整数对象和一个道字符串对象。
这些对象都可通过它们相应的分配器函数生成，但是更好的方式则是使用
@[green]DaoProcess@[green]类型的“工厂”方法产生。
这些方法一般以@[green]DaoProcess_New@[green]开头。
例如，生成道整数对象和道字符串对象，我们可以用：
@[code(cxx)]
// 准备道整数对象和道字符串对象:
DaoInteger *ivalue = DaoProcess_NewInteger( proc, 123 );
DaoString  *svalue = DaoProcess_NewString( proc, "abc", -1 );
@[code(cxx)]
The third parameter of 
@[green]DaoProcess_NewString()@[green]的第三个参数是前面C字符串的长度，
如果为负值，该字符串是以NULL作为结束标识。


这些对象必须放在数组里才能传递给"myfunction"函数：
@[code(cxx)]
DaoValue *params[2];
params[0] = (DaoValue*) ivalue;
params[1] = (DaoValue*) svalue;
@[code(cxx)]
因为这些对象是有@[green]DaoProcess@[green]的方法生成的，
你也可以通过下面的以数组得方式获得这些对象：
@[code(cxx)]
// 获取最后产生的两个对象:
DaoValue **params = DaoProcess_GetLastValues( proc, 2 );
@[code(cxx)]


@[subsection]
调用道函数
@[subsection]

现在我们已经可以用准备好的参数调用前面获得的函数了：
@[code(cxx)]
// 调用函数:
DaoProcess_Call( proc, myfunc, NULL, params, 2 );
@[code(cxx)]
对于类方法，一个类实例对象可作为该函数的第三个参数传入。
不过它也可作为@[cyan]params@[cyan]数组的第一个元素传入。
值得注意的是这个函数能处理重载过的函数，因此你不需要为此做任何事
（当然还是要传入正确的参数对象）。
没有错误的情况下，这个函数将返回零，否则返回一个表示错误的整数。


@[subsection]
获得函数的返回值
@[subsection]

如果上面的函数有返回值，该返回值可通过下面的函数获得：
@[code(cxx)]
// 获得函数的返回值:
DaoValue *retvalue = DaoProcess_GetReturned( proc );
@[code(cxx)]
如果函数只返回某个特定类型的值，那么你可用@[green]DaoValue_CastXXX()@[green]
之类的函数将获得的值转换到该类型。
你也可以使用@[green]DaoValue_TryGetXXX()@[green]将它直接转换到相应的C类型。
例如，如果"myfunction"返回整数，你可通过下面的方式获得。
@[code(cxx)]
// 获得返回的整数:
daoint retint = DaoValue_TryGetInteger( retvalue );
@[code(cxx)]

@[subsection]
释放虚拟进程对象
@[subsection]

当你使用完一个虚拟进程对象后，你需要释放它。
最好的方式是将它是放回@[green]DaoVmSpace@[green]对象，以便重用。
@[code(cxx)]
// 释放虚拟进程对象:
DaoVmSpace_ReleaseProcess( vmspace, proc );
@[code(cxx)]
但如果你需要频繁地使用一个虚拟进程对象，
你可以保留它直到最后不需要的时候。
不过这样的话，就有必要释放前面准备的参数了：
@[code(cxx)]
// 释放缓存的参数:
DaoProcess_PopValues( proc, 2 );
@[code(cxx)]


@[subsection]
将这些代码放在一起
@[subsection]

@[code(cxx)]
// 载入 "myscript.dao" 并获得命名空间对象:
DaoNamespace *nspace = DaoVmSpace_Load( vmspace, "myscript.dao" );
// 查找名为 "myfunction"的对象:
DaoValue *value = DaoNamespace_FindData( nspace, "myfunction" );
// 尝试转换为函数对象:
DaoRoutine *myfunc = DaoValue_CastRoutine( value );

// 获得进程对象:
DaoProcess *proc = DaoVmSpace_AcquireProcess( vmspace );

// 准备一个整数对象和字符串对象:
DaoInteger *ivalue = DaoProcess_NewInteger( proc, 123 );
DaoString  *svalue = DaoProcess_NewString( proc, "abc", -1 );
// 以数组的形式获得这两个对象:
DaoValue **params = DaoProcess_GetLastValues( proc, 2 );

// 调用函数:
DaoProcess_Call( proc, myfunc, NULL, params, 2 );

// 获取函数的返回值:
DaoValue *retvalue = DaoProcess_GetReturned( proc );
// 获取返回的整数值:
daoint retint = DaoValue_TryGetInteger( retvalue );

// 释放进程对象:
DaoVmSpace_ReleaseProcess( vmspace, proc );
@[code(cxx)]

@[text]


################################################################################
################################################################################
#### Extending Dao Virtual Machine
################################################################################
################################################################################
@[name]
daovm.interface.extending
@[name]

@[title]
扩展道虚拟机
@[title]

@[text]

帮助条文@[node]daovm.interface.embedding@[node]里的演示表明道虚拟机的嵌入方式极其简单。
这里将演示道虚拟机的扩展方式也极其简单。
因为道语言支持函数参数的类型标注，它可以省去你写很多样板代码和参数类型检查代码的麻烦。
也就是说，给道语言封装C/C++函数要比给其他如Python和Lua之类的语言封装C/C++函数要简单很多。


@[section]
第一个扩展模块例子
@[section]


@[subsection]
扩展函数原型
@[subsection]

所有可被道调用的函数都必须使用类似下面的原型：
@[code(cxx)]
void MyCFunction( DaoProcess *proc, DaoValue *param[], int nparam )
{
	printf( "Hello Dao!\n" );
}
@[code(cxx)]


@[subsection]
模块入口函数
@[subsection]

每个道模块都必须提供一个入口函数。下面这个"DaoOnLoad()"是个基本的入口函数名，
后面将会介绍入口函数名也可以包括模块名。
@[code(cxx)]
// Entry function for each C/C++ module:
int DaoOnLoad( DaoVmSpace *vmspace, DaoNamespace *ns );
@[code(cxx)]
这个函数将在模块载入时被调用，以便模块注册它的函数和类型等。
此函数的第一个参数是一个虚拟机空间@[green]DaoVmSpace@[green]对象。
此对象负责模块的载入和管理。
第二个参数是自动生成的命名空间对象，此对象将代表此模块，因此这个模块的
函数和类型等都应该注册到此命名空间。


如前面提到的，模块入口函数的名称可以包括模块的名称。
假如模块的名字以@[code(cxx)]load abc@[code(cxx)]或@[code(cxx)]load path.abc@[code(cxx)]
的方式出现在模块载入语句中，那么该名称可以如下方式出现在入口函数名中
（并且搜索方式也如下）：
@[list]
== 全小写字母: 例如 @[cyan]Daoabc_OnLoad@[cyan];
== 首大写字母: 例如 @[cyan]DaoAbc_OnLoad@[cyan];
== 全大写字母: 例如 @[cyan]DaoABC_OnLoad@[cyan];
@[list]


@[subsection]
函数注册
@[subsection]

下面的函数可用来将一个函数注册到命名空间@[green]DaoNamespace@[green]对象：
@[code(cxx)]
// 注册单个函数:
DaoRoutine*
DaoNamespace_WrapFunction( DaoNamespace *self, DaoCFunction fp, const char *proto );

// 注册多个函数:
int DaoNamespace_WrapFunctions( DaoNamespace *self, DaoFuncItem *items );
@[code(cxx)]
我们将在这里仅介绍第一个函数，第二个函数将在后面的小节里介绍。
这两个函数的第一个参数都是命名空间@[green]DaoNamespace@[green]对象，
函数将被注册到此对象里。第一个函数的第二个参数是函数指针类型@[green]DaoCFunction@[green]，
它的原型跟我们前面准备的函数@[cyan]MyCFunction@[cyan]一致；
第三个参数则是被注册函数在那个命名空间里的名称和原型。


下面将把上面的函数@[cyan]MyCFunction@[cyan]以"HelloDao()"注册到命名空间"nspace"里：
@[code(cxx)]
// 注册函数:
DaoNamespace_WrapFunction( nspace, MyCFunction, "HelloDao()" );
@[code(cxx)]
那么这个函数将在道里可以一@[cyan]HelloDao@[cyan]不带任何参数调用。


@[subsection]
总结
@[subsection]

把上面的放在一起将够成一个最简单的道扩展模块：
@[code(cxx)]
#include "dao.h"
#include "stdio.h"
static void MyCFunction( DaoProcess *proc, DaoValue *param[], int nparam )
{
	printf( "Hello Dao!\n" );
}
int DaoOnLoad( DaoVmSpace *vmspace, DaoNamespace *nspace )
{
	DaoNamespace_WrapFunction( nspace, MyCFunction, "HelloDao()" );
	return 0;
}
@[code(cxx)]
要编译这些代码，你将需要把道的头文件路径加到你的编译选项里。
并且你还需要声明以下预处理器定义：
@[list]
-- Win32 上: @[green]WIN32@[green];
-- Unix 上: @[green]UNIX@[green];
-- MacOSX 上: @[green]MACOSX@[green];
@[list]
在Windows上链接时，你还需要将道库链接到你的模块里。
在其他平台上加如下链接标识就可以了：
For linking, on Windows you will need to link the module against the Dao library.
But on the other platforms, you can simply use the following flags,
@[list]
-- Unix 上: @[green]-rdynamic@[green];
-- MacOSX 上: @[green]-undefined dynamic_lookup@[green];
@[list]
如果你使用DaoMake (@[node]tool.standard.daomake@[node]) 编译你的模块，
这些都将被自动处理好。


@[section]
第二个函数封装例子
@[section]

现在我们将展示如何封装可接受参数和可返回值的函数。
假定我们需要封装以下C函数
@[code]
float Test( int id, const char *name, int extra );
@[code]
并给最后的"extra"参数支持一个缺省值。
那么我们将需要封装的函数以下面的原型注册到道里：
@[code]
# 道函数原型
MyTest( id: int, name: string, extra = 0 ) => float
@[code]
这样，此函数将可以接受一个整数和一个字符串作为参数，以及另一个整数作为额外的参数。
这个函数原型也表示此函数将返回一个单精度浮点数。


在C封装函数里，将道数据类型转换到C数据类型的方式很简单，并且把C数据返回给道
的方式也很简单：
@[code(cxx)]
void MyTestInC( DaoProcess *proc, DaoValue *param[], int nparam )
{
	daoint id = param[0]->xInteger.value;
	char *name = param[1]->xString.value->chars;
	daoint extra = param[2]->xInteger.value;
	DaoProcess_PutFloat( proc, Test( id, name, extra ) );
}
@[code(cxx)]
正如你所看到的，你不需要检查参数个数或类型，就可以直接得到参数的数据。
当道程序调用这个函数时，它保证将有正确类型的参数值传递给这个函数。


但为了使用上述数据转换方式，你将需要在你的模块源文件里包含其他道虚拟机的头文件
（如@[green]daoValue.h@[green]）。
并且你还需要对道语言的内部标准数据结构有所了解。
如果你只想使用单一的@[green]dao.h@[green]头文件，你将需要使用那些
@[cyan]DaoValue_TryGetXXX()@[cyan]函数。这些函数将以很小的额外开销
作最少的类型检查，并返回适当的C数据。
@[code(cxx)]
void MyTestInC( DaoProcess *proc, DaoValue *param[], int nparam )
{
	daoint id = DaoValue_TryGetInteger( param[0] );
	char *name = DaoValue_TryGetChars( param[1] );
	daoint extra = DaoValue_TryGetInteger( param[2] );
	DaoProcess_PutFloat( proc, Test( id, name, extra ) );
}
@[code(cxx)]
如果你是以合适的道函数原型注册了这个函数，那些@[cyan]DaoValue_TryGetXXX()@[cyan]
里的类型检查都将成功，获得的都是正确的数据。
函数@[cyan]DaoProcess_PutFloat()@[cyan] 是用来从C封装函数里返回一个单精度浮点数
给道程序。这个浮点数将被放在到虚拟进程上合适的地方。
详情请看以下小节。


现在这个函数可被注册为：
@[code(cxx)]
// 注册一个带参数和返回值的函数:
DaoNamespace_WrapFunction( nspace, MyTestInC, "MyTest(id:int,name:string,extra=0)=>float" );
@[code(cxx)]





@[section]
C/C++类型的基本封装
@[section]

有两种使用C/C++类型来扩展道的方式。一种是不透明类型封装，
这是封装已有的C/C++类型的标准方式。
另一种是定义用户定制的C类型。

第一种主要是用在封装已有的C/C++类型。
There are two ways to extend Dao with user defined C/C++ types.
One is to wrap it around by a @[green]DaoCdata@[green] object,
and access it as an opaque pointer.
This is the standard way to wrap existing C/C++ types.
The other is to define a customized C type, and use it in the same way as the first.
A customized C type is a C structure sharing the same header fields as
@[green]DaoCdata@[green], which can make sharing types between Dao and C simpler
(especially for garbage collection).
Wrapped C/C++ types and customized C types can be added to Dao in almost the identical way,
so I will introduce the wrapped types first, and then the customized types should be very
easy to understand.


@[subsection]
Type information structure
@[subsection]

A C/C++ type can be used in Dao if only if it is registered in a Dao namespace
with a type information structure through,
@[code(cxx)]
DaoType* DaoNamespace_WrapType( DaoNamespace *self, DaoTypeBase *typer, int opaque );
int DaoNamespace_WrapTypes( DaoNamespace *self, DaoTypeBase *typer[] );
@[code(cxx)]
The @[cyan]opaque@[cyan] parameter must be set to 1 for wrapped types,
and 0 for customized types.


@[subsubsection]Structure definition@[subsubsection]

Here @[green]DaoTypeBase@[green] is defined as the following,
@[code(cxx)]
/* Type information structure for creating Dao types for C/C++ types: */
struct DaoTypeBase
{
	const char    *name;      /* type name; */
	DaoTypeCore   *core;      /* data used internally; */
	DaoNumItem    *numItems;  /* constant number list: should end with a null item; */
	DaoFuncItem   *funcItems; /* method list: should end with a null item; */

	/* typers for super types, to create c type hierarchy: */
	DaoTypeBase   *supers[ DAO_MAX_CDATA_SUPER ];

	/* function(s) to cast a C/C++ type to and from one of its parent type: */
	FuncPtrCast    casts[ DAO_MAX_CDATA_SUPER ];

	/* function to free data: */
	void  (*Delete)( void *self );

	/* Get garbage collectable fields (Dao data types with refCount by the type): */
	void  (*GetGCFields)( void *self, DArray *values, DArray *arrays, DArray *maps, int remove );
};
@[code(cxx)]
This structure defines the set of type information needed to create a corresponding Dao type.
Obviously each type needs a name, which can be set in the first field of this structure.
The second field is reserved for internal use for storing wrapped member constants and methods.


@[subsubsection]Member constant numbers and methods@[subsubsection]

The third field @[green]numItems@[green] can be used to specify a list of member constant numbers,
which are defined in an array of the following structure:
@[code(cxx)]
struct DaoNumItem
{
	const char *name;   /* contant name; */
	int         type;   /* number type; */
	double      value;  /* number value; */
};
@[code(cxx)]
The number type should be one of @[green]DAO_INTEGER@[green], @[green]DAO_FLOAT@[green]
and @[green]DAO_DOUBLE@[green]. The array should be terminated with a item with null name:
@[code(cxx)]
static DaoNumItem myTypeNumbers[] =
{
	{ "MODE_ONE", DAO_INTEGER, MODE_ONE },
	{ "MODE_TWO", DAO_INTEGER, MODE_TWO },
	{ NULL, 0, 0 }
};
@[code(cxx)]
If the type has no member constant numbers, it can be simply set to NULL.


The fourth field @[green]funcItems@[green] can be used to specify a list of member methods,
which are defined in an array of the following structure:
@[code(cxx)]
struct DaoFuncItem
{
	DaoCFunction  fpter;  /* C function pointer; */
	const char   *proto;  /* function prototype: name( parlist ) => return_type */
};
@[code(cxx)]
where the two fields @[cyan]fpter@[cyan] and @[cyan]proto@[cyan]
should be the same as they would in the parameter list of:
@[code(cxx)]
DaoRoutine*
DaoNamespace_WrapFunction( DaoNamespace *self, DaoCFunction fp, const char *proto );
@[code(cxx)]


@[subsubsection]Base types and casting functions@[subsubsection]

The fifth field @[green]supers@[green] can be use to expose the inheritance structure
of C/C++ types to Dao. To do this, one just need to set the @[green]supers@[green]
array to the type information structures of the parent types, and terminate the array
with a NULL pointer.


If the wrapped type is a C++ class with virtual method(s) or
virtual base(s), Dao will need to know how to cast this type to and from its parent
type properly. This can be done by specifying a list of cast functions in the sixth
field @[green]casts@[green] of the type structure.


If the C++ class has virtual method(s) but no virtual base(s), the cast function should
be provided in the following form,
@[code(cxx)]
void* cast_Sub_Base( void *data, int down_casting )
{
	if( down_casting ) return static_cast<Sub*>( (Base*)data );
	return dynamic_cast<Base*>( (Sub*)data );
}
@[code(cxx)]
And if the C++ class has virtual base(s), the cast function should be like,
@[code(cxx)]
void* cast_Sub_Base( void *data, int down_casting )
{
	if( down_casting ) return dynamic_cast<Sub*>( (Base*)data );
	return dynamic_cast<Base*>( (Sub*)data );
}
@[code(cxx)]


@[subsubsection]Deallocation and GC handling@[subsubsection]

If the C/C++ type should not be deallocated by the standard C function
@[green]free()@[green], a customized deallocation function must be specified for the
type structure. For wrapped C/C++ types, the @[cyan]self@[cyan] parameter passed
to the deallocation function will be the opaque C/C++ pointer,
and for customized C types, it will be the whole objects that have the same header fields
as @[green]DaoCdata@[green].


The last field @[green]GetGCFields@[green] can be normally set to NULL.
But if the C/C++ type may retain reference(s) to Dao data structures that
can form potentially cyclic referencing relationships, this field must be set
to a proper function.
The main purpose of this function is to expose the references retained by the C/C++
type to Dao garbage collector.
In this function, the pointers of Dao data that are directly referenced by the C/C++ type
should be pushed to the @[cyan]values@[cyan] parameters; and for Dao data that are
referenced through @[green]DArray@[green] structures, these @[green]DArray@[green] structures
should be pushed into the @[cyan]arrays@[cyan]; and for those that are referenced
through @[green]DMap@[green] structures, these @[green]DMap@[green] structures
should be pushed into the @[cyan]maps@[cyan].


This function is called with a zero @[cyan]remove@[cyan] parameter automatically by 
the garbage collector (GC) when an object of the C/C++ type needs to be scanned to determine 
if it is no longer reachable from the program.
It is also called before the object is deallocated by the GC,
this time the @[cyan]remove@[cyan] parameter is set to one,
and in this case, the @[green]GetGCFields@[green] must break the references that
are pushed into the @[cyan]values@[cyan], @[cyan]arrays@[cyan] and @[cyan]maps@[cyan] arrays.
This is necessary, because some of the objects referenced by the C/C++ object
can be deallocated by the GC, breaking references to them will avoid posible double deletion.


@[subsection]A simple example@[subsection]

Given the following C++ class,
@[code(cxx)]
class ClassOne
{
	public:
	int  value;

	enum{ CLASSONE_AA, CLASSONE_BB };

	ClassOne( int v );

	int Method( const char *s );
};
@[code(cxx)]
It can be wrapped in the following way,
@[code(cxx)]
// Declare the wrapper functions first:
static void dao_ClassOne_ClassOne( DaoProcess *proc, DaoValue *p[], int n );
static void dao_ClassOne_Method( DaoProcess *proc, DaoValue *p[], int n );
// List of constant member numbers for the enums:
static DaoNumItem ClassOneNumbers[] =
{
	{ "CLASSONE_AA", DAO_INTEGER, CLASSONE_AA },
	{ "CLASSONE_BB", DAO_INTEGER, CLASSONE_BB },
	{ NULL, 0, 0 }
};
// List of member constructors or methods of ClassOne:
static DaoFuncItem ClassOneMethods[] =
{
	// Methods with the same name as the type name are constructors:
	{ dao_ClassOne_ClassOne,  "ClassOne( v: int )" },
	{ dao_ClassOne_Method,    "Method( self: ClassOne, s: string ) => int" },
	{ NULL, NULL }
};
static void ClassOne_Delete( void *self )
{
	delete (ClassOne*) self;
}
// The type information structure for ClassOne:
static DaoTypeBase ClassOne_Typer = 
{
	"ClassOne", NULL, ClassOneNumbers, ClassOneMethods,
	{NULL}, {NULL}, ClassOne_Delete, NULL
};
// The Dao type structure for ClassOne:
DaoType *dao_type_ClassOne = NULL;

static void dao_ClassOne_ClassOne( DaoProcess *proc, DaoValue *p[], int n )
{
	// Get the integer parameter;
	daoint v = DaoValue_TryGetInteger( p[0] );
	// Create a ClassOne instance:
	ClassOne *self = new ClassOne( v );
	// Wrap the instance with Dao type structure:
	DaoProcess_PutCdata( proc, self, dao_type_ClassOne );
}
static void dao_ClassOne_Method( DaoProcess *proc, DaoValue *p[], int n )
{
	// Get the ClassOne instance:
	ClassOne *self = (ClassOne*) DaoValue_TryCastCdata( p[0], dao_type_ClassOne );
	// Get the string parameter:
	char *s = DaoValue_TryGetChars( p[1] );
	int res = self->Method( s );
	// Return the integer result:
	DaoProcess_PutInteger( proc, res );
}
int DaoOnLoad( DaoVmSpace *vmSpace, DaoNamespace *nspace )
{
	// Wrap ClassOne as an opaque C/C++ type:
	dao_type_ClassOne = DaoNamespace_WrapType( nspace, & ClassOne_Typer, 1 );
	return 0;
}
@[code(cxx)]


Since the @[cyan]value@[cyan] member of ClassOne is a public member,
it is reasonable to add a getter and a setter method to wrapped ClassOne type.
To add a getter, one only needs to register a method with name @[green].field@[green]
and no extra parameter.
And for a setter, the method name must be @[green].field=@[green],
and it must also accept a parameter with type the same as the value 
that can be assigned.
For example, for the @[cyan]value@[cyan] member,
one can added the following to the @[cyan]ClassOneMethods@[cyan] list,
@[code(cxx)]
// the getter and setter:
	{ dao_ClassOne_GETF_value,  ".value( self: ClassOne ) => int" },
	{ dao_ClassOne_SETF_value,  ".value=( self: ClassOne, value: int )" },
@[code(cxx)]
Here the name @[cyan]dao_ClassOne_GETF_value@[cyan] 
and @[cyan]dao_ClassOne_GETF_value@[cyan] are completely arbitrary.
They can be implemented in the following way,
@[code(cxx)]
static void dao_ClassOne_GETF_value( DaoProcess *proc, DaoValue *p[], int n )
{
	ClassOne *self = (ClassOne*) DaoValue_TryCastCdata( p[0], dao_type_ClassOne );
	DaoProcess_PutInteger( proc, self->value );
}
static void dao_ClassOne_SETF_value( DaoProcess *proc, DaoValue *p[], int n )
{
	ClassOne *self = (ClassOne*) DaoValue_TryCastCdata( p[0], dao_type_ClassOne );
	self->value = DaoValue_TryGetInteger( p[1] );
}
@[code(cxx)]


@[subsection]An advanced example@[subsection]

Now given the following class that is derived from @[cyan]ClassTwo@[cyan],
@[code(cxx)]
class ClassTwo : public ClassOne
{
	public:
	virtual void VirtualMethod( int i, float f );
};
@[code(cxx)]
Because this class has a virtual method, if we want Dao classes can be
derived from @[cyan]ClassTwo@[cyan] and reimplement its virtual functions,
the wrapping will be a bit more sophisticated.
First, we will need to define a "proxy" class that is derived from
@[cyan]ClassTwo@[cyan] and reimplements its virtual function 
such that this reimplemented function can check for
a Dao reimplementation of the function and invoke it if it exists.
When an instance of @[cyan]ClassTwo@[cyan] needs to be created,
an instance of this proxy class will be created and returned
instead of the original @[cyan]ClassTwo@[cyan].


Here is an example of such proxy class,
@[code(cxx)]
class Dao_ClassTwo : public ClassTwo
{
	public:

	DaoCdata *dao_cdata;

	Dao_ClassTwo();
	~Dao_ClassTwo();

	int VirtualMethod( int i, float f );
};
@[code(cxx)]
This proxy class will need to maintain a reference to the wrapper object,
so an extra field @[cyan]dao_cdata@[cyan] is declared in the class.
This wrapper object can be pre-allocated in the constructor of @[cyan]Dao_ClassTwo@[cyan],
@[code(cxx)]
Dao_ClassTwo::Dao_ClassTwo()
{
	dao_cdata = DaoCdata_New( dao_type_ClassTwo, this );
	DaoGC_IncRC( (DaoValue*)dao_cdata );
}
@[code(cxx)]
Here the @[cyan]dao_type_ClassTwo@[cyan] is the Dao type object for @[cyan]ClassTwo@[cyan],
and can be obtained in the same way as @[cyan]dao_type_ClassOne@[cyan].
Now that @[cyan]Dao_ClassTwo@[cyan] has a reference to a @[green]DaoCdata@[green]
object, the @[green]GetGCFields@[green] field of the type information structure
for @[cyan]ClassTwo@[cyan] should be set to a proper function, which will be provided later.
The destructor should also be handled this reference properly by,
@[code(cxx)]
Dao_ClassTwo::~Dao_ClassTwo()
{
	if( dao_cdata ){ // Could have been set to NULL by the GC:
		// Set the opaque pointer of dao_cdata to NULL, so that the deallocator
		// of DaoCdata will not attempt to call the deallocator of the opaque pointer:
		DaoCdata_SetData( dao_cdata, NULL );
		DaoGC_DecRC( (DaoValue*) dao_cdata );
	}
}
@[code(cxx)]


Then the @[cyan]VirtualMethod()@[cyan] could be implemented in the following way,
@[code(cxx)]
int Dao_ClassTwo::VirtualMethod( int i, float f )
{
	DaoVmSpace *vmspace = DaoVmSpace_MainVmSpace();
	DaoProcess *proc = NULL;

	// Try to get the instance of a derived Dao class:
	DaoObject *object = DaoCdata_GetObject( dao_cdata );
	if( object == NULL ) goto CallDefault;

	// Try to get a method named "VirtualMethod":
	DaoRoutine *method = DaoObject_GetMethod( object, "VirtualMethod" );
	if( method == NULL ) goto CallDefault;

	// Check if the method is a C/C++ wrapper function:
	if( DaoRoutine_IsWrapper( method ) ) goto CallDefault;

	// Acquire a process object to execute the re-implemented virtual function:
	proc = DaoVmSpace_AcquireProcess( vmspace );
	
	// Prepare function call parameters:
	DaoProcess_NewInteger( proc, i );
	DaoProcess_NewFloat( proc, f );
	DaoValue **params = DaoProcess_GetLastValues( proc, 2 );

	// Resolve possible overloading using the parameters:
	// This can be merged with DaoProcess_Call(), if the error code returned
	// by DaoProcess_Call() is checked an properly handled.
	method = DaoRoutine_Resolve( method, object, params, 2 );
	if( method == NULL ) goto CallDefault;

	// Run the re-implemented function:
	if( DaoProcess_Call( proc, method, object, params, 2 ) ) goto ErrorCall;

	// Check the returned value:
	DaoValue *res = DaoProcess_GetReturned( proc );
	if( DaoValue_CastInteger( res ) ) goto ErrorCall;

	int ires = DaoValue_TryGetInteger( res );

	// Release the process object:
	DaoProcess_Release( vmspace, proc );

	return ires;

CallDefault:
	if( proc ) DaoProcess_Release( vmspace, proc );
	return ClassTwo::VirtualMethod( i, f );
ErrorCall:
	DaoProcess_Release( vmspace, proc );
	// Do something;
	return 0;
}
@[code(cxx)]


Now we will define a function that can be set to the @[cyan]GetGCFields@[cyan]
field of the type information structure of @[cyan]ClassTwo@[cyan].
@[code(cxx)]
static void Dao_ClassTwo_GetGCFields( void *self0,
		DArray *values, DArray *arrays, DArray *maps, int remove )
{
	Dao_ClassTwo *self = (Dao_ClassTwo*) self0;
	if( self->dao_cdata == NULL ) return;
	DArray_Append( values, self->dao_cdata );
	if( remove ){
		// If this object cannot be deallocated because some other C/C++ objects
		// are using it, here is the right place to set the wrapped pointer (namely
		// this object) of dao_cdata to NULL, so that no deallocation will be
		// invoked for this object.
		//
		// For example, in some GUI library, if a widget has a parent, the parent
		// will be responsible for deleting the widget, so something like the
		// following can be used to support this:
		// if( self->parent() ) DaoCdata_SetData( self->dao_cdata, NULL );
		 
		// To avoid the deallocator of Dao_ClassTwo being called by the GC:
		self->dao_cdata = NULL;
	}
}
@[code(cxx)]


The remaining part for wrapping @[cyan]ClassTwo@[cyan] should be something like,
@[code(cxx)]
static void dao_ClassTwo_ClassTwo( DaoProcess *proc, DaoValue *p[], int n )
{
	Dao_ClassTwo *self = new Dao_ClassTwo();
	DaoProcess_PutValue( proc, (DaoValue*) self->dao_cdata );
}
static DaoFuncItem ClassTwoMethods[] =
{
	{ dao_ClassTwo_ClassTwo,  "ClassTwo()" },
	{ NULL, NULL }
};
static void Dao_ClassTwo_Delete( void *self )
{
	delete (Dao_ClassTwo*) self;
}
static void* Dao_ClassTwo_Cast_ClassOne( void *data, int down )
{
	if( down ) return static_cast<ClassTwo*>((ClassOne*)data);
	return dynamic_cast<ClassOne*>((ClassTwo*)data);
}
// The type information structure for ClassTwo:
static DaoTypeBase ClassTwo_Typer = 
{
	"ClassTwo", NULL, NULL, ClassTwoMethods,
	{ & ClassOne_Typer, NULL },
	{ Dao_ClassTwo_Cast_ClassOne, NULL },
	Dao_ClassTwo_Delete, NULL
};
// The Dao type structure for ClassTwo:
DaoType *dao_type_ClassTwo = NULL;

int DaoOnLoad( DaoVmSpace *vmSpace, DaoNamespace *nspace )
{
	...
	// Wrap ClassTwo as an opaque C/C++ type:
	dao_type_ClassTwo = DaoNamespace_WrapType( nspace, & ClassTwo_Typer, 1 );
	return 0;
}
@[code(cxx)]




@[section]
Data Conversion between Dao and C/C++
@[section]

Dao provides various C interface functions to make data conversion between Dao
and C/C++ simple. For simple data types, one can use the one of the following
functions to convert Dao values to C values,
@[code(cxx)]
daoint    DaoValue_TryGetInteger( DaoValue *self );
float     DaoValue_TryGetFloat( DaoValue *self );
double    DaoValue_TryGetDouble( DaoValue *self );
complex16 DaoValue_TryGetComplex( DaoValue *self );
char*     DaoValue_TryGetChars( DaoValue *self );
DString*  DaoValue_TryGetString( DaoValue *self );
int       DaoValue_TryGetEnum( DaoValue *self );

void*     DaoValue_TryGetCdata( DaoValue *self );
void**    DaoValue_TryGetCdata2( DaoValue *self );
void*     DaoValue_TryCastCdata( DaoValue *self, DaoType *totype );
@[code(cxx)]
If the @[green]DaoValue@[green] object is of the requested type, the correct data
will be returned, otherwise zero or a null pointer is return.
The last three functions are execlusively for wrapped C/C++ types,
we come to this later.


For other data types, you may need to cast @[green]DaoValue@[green] objects
to proper types, and then use proper methods to retrieve C data values.
There are two ways to cast from @[green]DaoValue@[green] to other types,
one is to use @[green]DaoValue_Type()@[green] to check its type and than do C casting,
the other is to use one of the @[green]DaoValue_CastXXX()@[green] series of methods.
For example, the following are the two ways to cast @[cyan]value@[cyan] 
from @[green]DaoValue@[green] to @[green]DaoTuple@[green],
@[code(cxx)]
DaoTuple *tup1 = DaoValue_Type( value ) == DAO_TUPLE ? (DaoTuple*) value : NULL;
DaoTuple *tup2 = DaoValue_CastTuple( value );
@[code(cxx)]
@[green]DaoValue_CastXXX()@[green] methods will return NULL, if the value
is not the correct type.


@[text]
