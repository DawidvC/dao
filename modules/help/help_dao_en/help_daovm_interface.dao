load help;

@[name]
daovm.interface
@[name]

@[title]
Programming with The C Interfaces
@[title]


################################################################################
################################################################################
#### Embedding Dao Interpreter
################################################################################
################################################################################
@[name]
daovm.interface.embedding
@[name]

@[title]
Embedding Dao Interpreter
@[title]

@[text]

@[section]
A Simple Example
@[section]

@[subsection]
Initializing Dao Runtime
@[subsection]

Before doing anything with Dao as a library, one must call
@[green]DaoInit()@[green] to initialize it first:

@[code]
# Initialize Dao:
DaoVmSpace *vmspace = DaoInit( NULL );
@[code]
This function will return a @[green]DaoVmSpace@[green] object,
which can be used to load Dao scripts or modules.
It can optionally take @[cyan]char*@[cyan] parameter,
which is assumed to be the path and name of the application,
and is used to add additional searching paths.

@[comment]
Before you start to use the @[green]DaoVmSpace@[green] object
to run Dao scripts or load Dao modules, you may set some options
in the object, e.g:
@[code]
DaoVmSpace_SetOptions( vmspace,  );
@[code]
@[comment]

@[subsection]
Load A Script File
@[subsection]

Once you have a @[green]DaoVmSpace@[green] object, you can start
to run Dao scripts or load Dao modules using this object.
If you have a main script file and all you need to do is to run the file,
you can simply call:

@[code]
# Load "myscript.dao":
DaoVmSpace_Load( vmspace, "myscript.dao" );
@[code]

@[subsection]
Finalize Dao Runtime
@[subsection]

After you are done with Dao, you may call the following function
to make sure, Dao is properly finalized (waiting for unjoined threads
to finish, or waiting for garbage to finish, and some internal data structures
are deallocated etc.).
@[code]
# Finalize (or Quit) Dao:
DaoQuit();
@[code]

@[subsection]
Putting These Codes Together
@[subsection]

@[code]
# Initialize Dao:
DaoVmSpace *vmspace = DaoInit( NULL );
# Load "myscript.dao":
DaoVmSpace_Load( vmspace, "myscript.dao" );
# Finalize (or Quit) Dao:
DaoQuit();
@[code]

@[section]
A Slightly More Advanced Example
@[section]

In Dao, each single script file is represented by one namespace object.
And each namespace object has access to the public global constants and 
variables defined in the files that this file has loaded.
To do any thing interesting, one must obtain the namespace object
for the file of interest.


@[subsection]
Obtaining The Namespace Object
@[subsection]

Following the above example, if you want to call a function defined
in "myscript.dao" (or in the files it has loaded), you can simple
store the returned namespace object in a variable,
@[code]
# Load "myscript.dao" and obtain the namespace object:
DaoNamespace *nspace = DaoVmSpace_Load( vmspace, "myscript.dao" );
@[code]


@[subsection]
Obtaining The Function Object
@[subsection]

To find the function you want to call,
@[code]
# Find an object named "myfunction":
DaoValue *value = DaoNamespace_FindData( nspace, "myfunction" );
# Try to cast it to a function object:
DaoRoutine *myfunc = DaoValue_CastRoutine( value );
@[code]
If "myfunction" is indeed a function, @[cyan]myfunc@[cyan] will not be NULL.


@[subsection]
Obtaining A Process Object
@[subsection]

Now to call the function, you will need another type of object:
@[green]DaoProcess@[green], which represents a virtual machine process
and is responsible to execute scripts.
You can directly call @[green]DaoProcess_New()@[green] to create a new
process object, but normally the better to get a process object is to
acquire it from a @[green]DaoVmSpace@[green] object:
@[code]
# Acquire a process object:
DaoProcess *proc = DaoVmSpace_AcquireProcess( vmspace );
@[code]

@[subsection]
Prepare Parameter Values
@[subsection]

Now suppose the function "myfunction" needs to take an integer as its first
parameter and a string as the second. To call it, we will need to prepare
parameters that can be passed to this function.
The simplest way to do this is to use the data "factory" methods that
are associated with the process type @[green]DaoProcess@[green].
Such methods are normally begin with @[green]DaoProcess_New@[green].
For example, to prepare an integer value and a string value, one can do,

@[code]
# Prepare an integer and a string:
DaoInteger *ivalue = DaoProcess_NewInteger( proc, 123 );
DaoString  *svalue = DaoProcess_NewMBString( proc, "abc", -1 );
@[code]
The third parameter of @[green]DaoProcess_NewMBString()@[green]
is the number of bytes in the C string, and a negative value can be
used to indicate the C string is NULL terminated.


To use these two new values in the parameter list to call "myfunction",
you can do,
@[code]
DaoValue *params[2];
params[0] = (DaoValue*) ivalue;
params[1] = (DaoValue*) svalue;
@[code]
Or you can simply do,

@[code]
# Get the last two values:
DaoValue **params = DaoProcess_GetLastValues( proc, 2 );
@[code]
which will return last created two values in an array.


@[subsection]
Call The Function
@[subsection]

Now we are ready to call the function we obtained before with
the prepared values,
@[code]
# Call the function:
DaoProcess_Call( proc, myfunc, NULL, params, 2 );
@[code]
For class methods, a class instance object can be passed to this function
as the third parameter, or it can be passed as the first value of 
@[cyan]params@[cyan].
Please note that, this function can handle overloaded functions automatically!
So you do not need to do anything for that.
This function will return zero on success, or other values with errors.


@[subsection]
Retrieve The Returned Value
@[subsection]

If the function returns a value, you can obtain it by,
@[code]
# Obtain the returned value:
DaoValue *retvalue = DaoProcess_GetReturned( proc );
@[code]
If the returned value is supposed to be of certain type,
you can cast it to that type by using one of the 
@[green]DaoValue_CastXXX()@[green] functions,
or directly convert it to a proper C type by using one of the
@[green]DaoValue_TryGetXXX()@[green] functions.
For example, if "myfunction" returns an integer,
you can get it by,
@[code]
# Get the integer return value
daoint retint = DaoValue_TryGetInteger( retvalue );
@[code]

@[subsection]
Release The Process Object
@[subsection]

After you have done with the process object, you can release it
back the @[green]DaoVmSpace@[green] object,
@[code]
# Release the process:
DaoVmSpace_ReleaseProcess( vmspace, proc );
@[code]
But if you want to use a process object frequently,
you may simply retain it until you no longer need it.


@[subsection]
Putting These Codes Together
@[subsection]

@[code]
# Load "myscript.dao" and obtain the namespace object:
DaoNamespace *nspace = DaoVmSpace_Load( vmspace, "myscript.dao" );
# Find an object named "myfunction":
DaoValue *value = DaoNamespace_FindData( nspace, "myfunction" );
# Try to cast it to a function object:
DaoRoutine *myfunc = DaoValue_CastRoutine( value );

# Acquire a process object:
DaoProcess *proc = DaoVmSpace_AcquireProcess( vmspace );

# Prepare an integer and a string:
DaoInteger *ivalue = DaoProcess_NewInteger( proc, 123 );
DaoString  *svalue = DaoProcess_NewMBString( proc, "abc", -1 );
# Get the last two values:
DaoValue **params = DaoProcess_GetLastValues( proc, 2 );

# Call the function:
DaoProcess_Call( proc, myfunc, NULL, params, 2 );

# Obtain the returned value:
DaoValue *retvalue = DaoProcess_GetReturned( proc );
# Get the integer return value
daoint retint = DaoValue_TryGetInteger( retvalue );

# Release the process:
DaoVmSpace_ReleaseProcess( vmspace, proc );
@[code]

@[text]


################################################################################
################################################################################
#### Extending Dao Interpreter
################################################################################
################################################################################
@[name]
daovm.interface.extending
@[name]

@[title]
Extending Dao Interpreter
@[title]

@[text]

In the help entry @[blue]daovm.interface.embedding@[blue], it has been 
demonstrated that embedding Dao is extremely simple.
Here we will demonstrate that extending Dao is also extremely simple.
Since Dao supports explicit type specification in function parameter lists,
you will not need to write a lot of boilerplate codes to check and 
convert function parameters from Dao data types to C/C++ data types.
This means writing wrapping functions (Dao-callable C functions) 
is significantly simpler than writing wrapping functions
for other languages such as Python or even Lua.


@[section]
The First Simple Extending Module
@[section]

All Dao-callable C functions must have prototype similar to the following
example,
@[code]
void MyCFunction( DaoProcess *proc, DaoValue *param[], int nparam )
{
	printf( "Hello Dao!\n" );
}
@[code]

Each Dao extending module must provide an entry function,
@[code]
# Entry function for each C/C++ module:
int DaoOnLoad( DaoVmSpace *vmspace, DaoNamespace *ns );
@[code]
This function will be called automatically to allow the module
to register its functions and types etc.
The first parameter is the @[green]DaoVmSpace@[green] instance
which is responsible for loading and managing the module.
And the second parameter is the namespace object that will
represent this module, so all the functions and types etc.
should be registered to this namespace.


This function can also be name as @[cyan]DaoXXX_OnLoad@[cyan],
where @[cyan]XXX@[cyan] is the module name that will appear
in a load statement such as @[code]load XXX@[code]
or @[code]load path.XXX@[code].


To register functions to a namespace, one can use one of the
following interface functions of @[green]DaoNamespace@[green],
@[code]
# Function to register a single function:
DaoRoutine* DaoNamespace_WrapFunction( DaoNamespace *self,
                                       DaoCFunction fp, 
                                       const char *proto );

# Functions to register multiple functions:
int DaoNamespace_WrapFunctions( DaoNamespace *self, DaoFuncItem *items );
@[code]
We will come to the second function later.
For the first function, the first parameter is the namespace to which
the function is registering to; the second is the function pointer to
the function that needs to be registered (@[cyan]MyCFunction@[cyan] in this case);
and the last parameter is the Dao function prototype for the registered function.


So you can register the above function @[cyan]MyCFunction@[cyan] as the following,
@[code]
# Register function:
DaoNamespace_WrapFunction( nspace, MyCFunction, "HelloDao()" );
@[code]
So that this function can be called in Dao by name @[cyan]HelloDao@[cyan]
without any parameter.


To sum it up, the simplest Dao extending module could be the following,
@[code]
#include "dao.h"
#include "stdio.h"
static void MyCFunction( DaoProcess *proc, DaoValue *param[], int nparam )
{
	printf( "Hello Dao!\n" );
}
int DaoOnLoad( DaoVmSpace *vmspace, DaoNamespace *nspace )
{
	DaoNamespace_WrapFunction( nspace, MyCFunction, "HelloDao()" );
}
@[code]
To compile it, you will need to add the Dao header file path to your compiling
option. And you will also need to add the following preprocessor definitions:
@[list]
-- On Win32: @[green]WIN32@[green];
-- On Unix: @[green]UNIX@[green];
-- On Mac OSX: @[green]UNIX@[green] plus @[green]MAC_OSX@[green];
@[list]
For linking, on Windows you will need to link the module against the Dao library.
But on the other platforms, you can simply use the following flags,
@[list]
-- On Unix: @[green]-rdynamic@[green];
-- On Mac OSX: @[green]-undefined dynamic_lookup@[green];
@[list]


@[section]
The Second Simple Extending Module
@[section]

Now we will demonstrate how to create a function that can accept
parameters and return a value.
Suppose we want to create C function with the following Dao function prototype,
@[code]
# Dao function prototype
MyTest( id :int, name :string, extra = 0 ) => float
@[code]
So this function will take an integer parameter, a string parameter and 
an extra integer parameter with default value. This prototype also indicates
that it will return a float.


In the C function, it is very easy to convert Dao data type to C data type,
and to return C data type to Dao,
@[code]
void MyTestInC( DaoProcess *proc, DaoValue *param[], int nparam )
{
	daoint id = DaoValue_TryGetInteger( param[0] );
	char *name = DaoValue_TryGetMBString( param[1] );
	daoint extra = DaoValue_TryGetInteger( param[2] );
	printf( "MyTest: %i %s %i\n", id, name, extra );
	DaoProcess_PutFloat( proc, 0.5*(id + extra) );
}
@[code]
As you can see, there are no boilerplate codes to check the number of parameters
and the type of parameters.
If the execution reaches the function body of @[cyan]MyTestInC()@[cyan],
it is guaranteed that all the parameter values are available with correct types.


Actually the @[cyan]DaoValue_TryGetXXX()@[cyan] methods did check the value type,
but in this case, they will always succeed. So if you include the header file
@[green]daoValue.h@[green] in your source file, you can simple write the 
function as the following to completely (safely) remove the type checking,
@[code]
void MyTestInC( DaoProcess *proc, DaoValue *param[], int nparam )
{
	daoint id = param[0]->xInteger.value;
	char *name = DString_GetMBS( param[1]->xString.data );
	daoint extra = param[2]->xInteger.value;
	printf( "MyTest: %i %s %i\n", id, name, extra );
	DaoProcess_PutFloat( proc, 0.5*(id + extra) );
}
@[code]
But the downside of this is that you need to be familiar with the internal Dao
data structures.


These @[cyan]DaoValue_TryGetXXX()@[cyan] functions will convert the Dao values
to the requested C values.
And @[cyan]DaoProcess_PutFloat()@[cyan] will put a float value at proper location
as the returned value of the C function.
Please see the following section(s) for more details.


@[section]
Data Conversion between Dao and C/C++
@[section]

Dao provide various C interface functions to make data conversion between Dao
and C/C++ simple. For simple data types, one can use the one of the following
functions to convert Dao values to C values,
@[code]
daoint    DaoValue_TryGetInteger( DaoValue *self );
float     DaoValue_TryGetFloat( DaoValue *self );
double    DaoValue_TryGetDouble( DaoValue *self );
complex16 DaoValue_TryGetComplex( DaoValue *self );
char*     DaoValue_TryGetMBString( DaoValue *self );
wchar_t*  DaoValue_TryGetWCString( DaoValue *self );
DString*  DaoValue_TryGetString( DaoValue *self );
int       DaoValue_TryGetEnum( DaoValue *self );

void*     DaoValue_TryGetCdata( DaoValue *self );
void**    DaoValue_TryGetCdata2( DaoValue *self );
void*     DaoValue_TryCastCdata( DaoValue *self, DaoType *totype );
@[code]
If the @[green]DaoValue@[green] object is of the requested type, the correct data
will be returned, otherwise zero or a null pointer is return.
The last three functions are execlusively for wrapped C/C++ types,
we come to this later.


For other data types, you may need to cast @[green]DaoValue@[green] objects
to proper types, and then use proper methods to retrieve C data values.
There are two ways to cast from @[green]DaoValue@[green] to other types,
one is to use @[green]DaoValue_Type()@[green] to check its type and than do C casting,
the other is to use one of the @[green]DaoValue_CastXXX()@[green] series methods.
For example, the following are the two ways to cast @[cyan]value@[cyan] 
from @[green]DaoValue@[green] to @[green]DaoTuple@[green],
@[code]
DaoTuple *tup1 = DaoValue_Type( value ) == DAO_TUPLE ? (DaoTuple*) value : NULL;
DaoTuple *tup2 = DaoValue_CastTuple( value );
@[code]
@[green]DaoValue_CastXXX()@[green] methods will return NULL, if the value
is not the correct type.


@[text]
