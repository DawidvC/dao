load help;

@[name]
dao.guide
@[name]

@[title]
Quick Guide
@[title]

@[text]

This quick guide will cover some basics of Dao programming.
We will start with the traditional @[green]hello world@[green] example.


@[subsection]
Hello World!
@[subsection]

To simply write "Hello world!" to the screen, one can use,
@[code]
io.write( 'Hello world!' )
@[code]
In this simple example, the built-in @[green]io@[green] module is used
to access the IO functionalities of the module.
@[green]write()@[green] is a method provided by the @[green]io@[green] module
to write outputs on to the standard output (the screen in this case).
In Dao, string can be quoted with a pair of single quotation marks
or with a pair of double quotation marks.
Semicolons are optional at the end of statements.


@[subsection]
Running Scripts
@[subsection]

There are three ways to run codes in Dao.
The most typical way is to create a script file (e.g. @[cyan]hello_world.dao@[cyan]),
and put the codes into this file, and then run @[green]dao@[green] using this file
as argument,
@[code]
$$ dao hello_world.dao
@[code]

But if you just want to run the codes once, you can simple run them from command line using,
@[code]
$$ dao -e "io.write( 'Hello world!' )"
@[code]

For learning Dao, it may be the best to run codes in interactive mode.
Invoking @[green]dao@[green] without any argument will start an interactive shell,
@[code]
$$ dao

  Dao Virtual Machine 2.0
  Built date: Jun 12 2014
  Changeset ID: FOS.4d5eb15f0e53

  Copyright(C) 2006-2014, Fu Limin
  Dao is released under the terms of the Simplified BSD License
  Dao Language website: http://www.daovm.net

(dao) 
@[code]


@[subsection]
Accessing Online Help
@[subsection]

If you have the Dao @[green]help@[green] properly installed,
starting @[green]dao@[green] in interactive mode will automatically load
the help files and print out the following information,
@[code]
  Module Help is loaded.
  Now you may run "help()" to list all the available help entries;
  or run "help('help')" for detailed information about the help system.
@[code] 
If you are reading this tutorial from a webpage, and want to access it from
the interactive command line, you can simple run,
@[code]
(dao) help( 'dao.tutorial.basics' )
@[code]

Such online helps come in two languages: English and Chinese.
Currently the English version is more complete.
To choose the language,
@[code]
help::set_language("en");  # choose english;
help::set_language("zh");  # choose chinese;
@[code]


@[subsection]
Commenting Codes
@[subsection]

It is always a good idea to comment your codes.
Dao supports both single line comments and multiple line comments.
A single comment starts at a @[green]#@[green] 
(not followed by a left curly bracket @[green]{@[green]),
and ends at the end of the current line.
And a multiple line comment (or just part of a single line)
opens by @[green]#{@[green] and closes by @[green]#}@[green].
For example,
@[code]
# This is a simple demo:
io.write( "Hello World!" #{ comment inside codes #} );
#{
Here are multi-lines comments.
Here are multi-lines comments.
#}
@[code]


@[subsection]
Constants, Variables and Invariables
@[subsection]

Dao supports the explicit declaration of constants, local variables,
static variables, global variables and invariables.
Constants are declared with keyword @[green]const@[green],
@[code]
const DEFAULT_INDEX = 123
const DEFAULT_NAME  = 'abc'
@[code]
Constants can only be initialized with constant expression.
Constants that are declared at the top lexical scope are global constants.


Keyword @[green]var@[green] can be used to declare local and global variables.
If used at the top lexical scope, it will declare global variables,
otherwise the declared variables will be local.
@[code]
var current_index = 456    # global variable;
var current_name  = 'def'  # global variable;
if( current_index ) {
	var temp_index = current_index  # local variable;
}
@[code]

In every places where @[green]var@[green] can be used, @[green]invar@[green]
can be used as well, to declare local, global or member invariables.
Invariables are special kind of variables that cannot be modified once initialized.
@[code]
var   varlist = { 123 }
invar invlist = varlist

invlist.append( 456 )  # Error!
@[code]
Please see @[node]dao.data.invar@[node] for more information.


Another type of variable is the static variable which can be declared with
the @[green]static@[green] keyword. Outside class body, a static variable
is a global variable with strictly local visibility within its declaration
scope. So if a routine with static variables is executed multiple times,
all the executions will access the same static variables.
Static variables must be initialized with constant expressions.


Without the above specifiers, newly declared symbols in the form of
@[code]name=expression@[code] will be automatically declared as local variables. 
But if the symbol was defined as variable, such statements will simply
reinitialize the existing variable.
To avoid this, one must the keyword @[green]var@[green] to explicitly
declare the variable as local,
@[code]
var index = 789
for( i = 1 : 3 ){
	var index = 123  # Local to the loop;
}
@[code]

Please read @[node]dao.data@[node] for more information.

@[red]
Note: in interactve mode, all top level variables are automatically declared
as global variables.
@[red]


@[subsection]
Type Annotation
@[subsection]

In the above examples, no type information is declared for the constants,
variables and invariables.
Their types are automatically inferred from the values that were used
to initialize them.
In many cases, it is better to provide type annotations to the constant,
variable and invariable declarations. In general, programs with good
type annotations are more readable them programs without them.


Type annotations are usually placed after the constant/variable/invariable names
with a colon sparating them.
@[code]
const vector: array<float> = [ 12.5, 34.6 ]

var varlist: list<int>

invar invlist: list<float> = { 12.5, 34.6 }
@[code]
Here without type annotation, "vector" will become a constant of type "array<double>".
And "varlist" is declared without initializing expression, so its type cannot be
inferred here.


As you will see, type annotations can also be used in routine/function signatures
and class member fields.
Please read @[node]dao.type@[node] for more information.




@[subsection]
Data Types
@[subsection]

Dao supports a good number of data types to facilitate programming.
These include several number types, enum symbol, string, numeric array,
tuple, list and map etc. types. 


@[subsubsection]
Numbers
@[subsubsection]

Dao has native supports for the following number types:
@[green]int@[green], @[green]float@[green], @[green]double@[green],
and @[green]complex@[green].
Integer and floating point numbers can be expressed
in the same ways as in most other languages.
Floating point numbers in Dao are parsed as double precision numbers by default.
To explicitly express a single (double) precision floating point number,
it is necessary to append a suffix @[green]F@[green] (@[green]D@[green])
to a normally expressed number.


The imaginary part of a @[green]complex@[green] number can be expressed as an 
@[green]int@[green] or @[green]float@[green] number with a @[green]C@[green] suffix.
A general @[green]complex@[green] number can be expressed by combining
an integer or a floating point number as the real part and an imginary part,
which are both stored as double precision floating point numbers.


Examples,
@[code]
I1 = 123     # Base-10 integer;
I2 = 0xabc   # Base-16 integer;
F1 = 456.7F  # Single precision with suffix "F";
F2 = 123e4   # Single precision with lower case "e";
D1 = 123D    # Double precision with suffix "D";
D2 = 456.7   # Double precision by default; Or: 456.7D;
D3 = 123E4   # Double precision with upper case "E";
C1 = 123C    # Double precision complex number with 0.0 real part and 123 imag part;
C2 = 456.6C  # Double precision complex number;
@[code]


These types support most of the common operators that are meaningful for them.
For example, all the basic arithmetic operators such as:
@[green]+@[green] (addition, unary plus), @[green]-@[green] (subtraction, unary minus),
@[green]*@[green] (multiplication), @[green]/@[green] (division),
@[green]%@[green] (modulo) and @[green]**@[green] (power)
are supported.
@[code]
I1 = 123 + 456
I2 = 789 % 123
F1 = 123.5 ** 3
D1 = 789.5D / 123
@[code]

Please see @[node]dao.type.int@[node], @[node]dao.type.float@[node],
@[node]dao.type.double@[node] and @[node]dao.type.complex@[node]
for more information.


@[subsubsection]
Enum Symbols
@[subsubsection]

An @[green]enum@[green] defines a set of symbols with associated integer values.
@[code]
enum MyEnum
{
	AA    ,  # 0
	BB = 3,  # 3
	CC       # 4
}
@[code]
These symbols are not exposed to the current namespace.
So they have to be accessed as fields of the enum type,
@[code]
a = MyEnum::AA  # Or: MyEnum.AA;
@[code]


There is a special type of enum called @[green]symbol@[green],
which appears as an ordinary identifier prefixed with 
a dollar sign @[green]$@[green].
Such symbols are often used in conjunction with normal enum types.
@[code]
enum E1 { AA=1, BB=2 }
enum E2 { AA=10, BB=20 }

var e1 : E1 = $AA
var e2 : E2 = $AA

io.writeln( e1 )  # Output: $AA(1)
io.writeln( e2 )  # Output: $AA(10)
@[code]
Here symbol "$AA" is assigned to both "e1" and "e2", and the symbol
get interpreted properly according the types of "e1" and "e2".
So a symbol is a like a "polymorphic" enum: it can be used freely without
being fixed to a particular enum type, but its actually value will
depend on the type of the variable that holds it.


Another way to use enum types is to use the enum type names:
@[code]
var e1 : enum<AA,BB> = $AA
var e2 : enum<AA=10,BB=20> = $BB
@[code]

There are different types of enum types to support different operations.
Please see @[node]dao.type.enum@[node] for more information.




@[subsubsection]
Strings
@[subsubsection]

In Dao, a string can be expressed as a sequence of characters enclosed by
a pair of single qutotation marks or a pair of double quotation marks.
The characters placed between the quotation marks must be formated according
some rules (such as escaping quotation marks and other special characters
and using numeric encodings of characters etc.).
Please see @[node]dao.type.string@[node] for more information.
@[code]
mbs = 'str'
wcs = "道语言"
mbs2 = 'It\'s green'
wcs2 = "\u9053\u8bed\u8a00" # the same as wcs: "道语言";
@[code]


To use strings as it is written without special treatment of the characters,
they can be expressed as @[green]verbatim@[green] string, which are quoted with
a pair of identical compound marks in the forms of @[green]@[]@[green]
and @[green]@@[]@[green].
Any number of letters, digits, underscores, blank spaces, dots, 
colons, dashes and assignment marks can be placed in between the squared brackets
to make sure the marks will not appear inside the string.
The difference between using @[green]@[]@[green] and @[green]@@[]@[green]
is the same as the difference between using single quotation marks and double quotation marks.
Please see @[node]dao.type.string@[node] for more information.
@[code]
# C++ codes in MBS:
cpp =
@[cpp x]
class AA
{
	int index;
};
struct BB{};
@[cpp x]


# Lua codes in WCS:
lua =
@@[lua]
local a = 1;
function Test()
	io.write( 'Hello' )
end
@@[lua]
@[code]

The content of a string can be accessed or altered using sub-indexing or slicing:
@[code]
str = 'ABCDEFGHIJK';

io.writeln( str[1] )    # the second character;
io.writeln( str[:4] )   # the substring from the start to the 4th character;
io.writeln(  str[6:] )  # the substring from the 6th character to the end;
io.writeln(  str[3:8] ) # the substring from the 3rd to the 8th character;

# Set single character:
str[1] = 'X';
str[1] = 'X'[0];

# Set a substring:
str[2:5] = '1234'   # str = 'AB1234GHIJK'
str[2:5] = '123456' # str = 'AB123456GHIJK'
str[2:5] = '12'     # str = 'AB12GHIJK'

# Using negative index:
io.writeln( str[-1] )    # the last character;
io.writeln( str[-2:] )   # the last two characters;
@[code]

String can be concaternated using @[green]+@[green] or @[green]+=@[green],
@[code]
str = 'ABCDEFGHIJK';

str2 = str + '123'  # str2 = ABCDEFGHIJK123

# Append a string:
str += '123' # str = ABCDEFGHIJK123

# Append a character:
str += 88    # str = ABCDEFGHIJK123X
@[code]





@[subsubsection]
Numeric Arrays
@[subsubsection]

Dao has built-in support for multi-dimensional numeric arrays.
Such arrays can be defined by using the squared brackets
@[green][]@[green] or @[green]array{}@[green].
Using such constructs, one can either enumerate all the elements
as a vector/matrix, or specify an arithmetic progression with
a start value, a step value and the number of steps.
If the step value is omitted, it will be assumed to be zero.

@[code]
vec1 = [1, 2, 3]  # array<int> vector, or 1x3 matrix;
vec2 = [1.0; 2; 3]  # array<float> 3x1 matrix, or transposed vector;
mat1 = [1D, 2; 3, 4]  # array<double> 2x2 matrix;
mat2 = [ [1, 2], [3, 4] ]  # 2x2 matrix
mat3 = [ [1, 2, 3] : 5 ]   # 5x3 matrix;
mat4 = array{ 1, 2; 3, 4 }  # 2x2 matrix
@[code]

Like string, array support sub-indexing, slicing and negative indices:
@[code]
mat = [ 1, 2, 3; 4, 5, 6; 7, 8, 9 ];  # 3x3 matrix;

rowvec = mat[1,:]  # the second row;
colvec = mat[:,1]  # the second column;

submat1 = mat[:1,:]  # the first two rows;
submat2 = mat[:,1:]  # the last two columns;
submat3 = mat[:1,1:] # intersection between the first two rows and the last two columns;

mat[0,:]  = [11, 22, 33]  # set the first row to [11, 22, 33];
mat[:,1] += [11, 22, 33]  # add [11, 22, 33] to the second column;
mat[:,1] += 100           # add 100 to the second column;

mat[:1,1:] += [10, 20; 30, 40]  # add [10, 20; 30, 40] to sub-matrix of mat;
@[code]

Please see @[node]dao.type.array@[node] for more information.




@[subsubsection]
Lists
@[subsubsection]

List can be created in similar ways as array, by enumerating elements or specifying
an arithmetic progression, but using @[green]{}@[green] or @[green]list{}@[green]
instead of @[green][]@[green] or @[green]array{}@[green].

@[code]
list1 = { 1, 2, 3 }    # list<int>
list2 = { 1.0, 2, 3 }  # list<float>
list3 = { 1 : 2 : 5 }  # list<int>

list4 = { 'abc', 'def' }  # list<string>
list5 = { 123, 'abc' }    # list<any>

list6 = list{ 'a' : 3 }    # { 'a', 'a', 'a' }
list7 = { 'a' : 'b' : 3 }  # { 'a', 'ab', 'abb' }
@[code]

List also supports sub-indexing, slicing and negative indices:
@[code]
alist = { 0, 1, 2, 3, 4, 5 }

item = alist[1]
item = alist[-2]

sublist = alist[2:4]

alist[3]  = 10
alist[4] += 10
@[code]





@[subsubsection]
Maps and Hash Maps (Associative Arrays)
@[subsubsection]

A map or hash map organizes a set of key/value pairs into a structure
for efficient lookup. The keys in a map are ordered, while the keys
in a hash map are unordered.
A map can be created using @[green]{key=>value...}@[green] or
@[green]map{key=>value...}@[green]. Replacing the @[green]=>@[green]
with colon @[green]->@[green] will create hash maps.
Map and hash map can be used in identical ways.
@[code]
amap  = { 'abc' => 123, 'def' => 456 }
ahash = { 'abc' -> 123, 'def' -> 456 }

amap  = map{ 'abc' => 123, 'def' => 456 }
ahash = map{ 'abc' -> 123, 'def' -> 456 }
@[code]

Sub-scripting and slicing are also supported for map to access value(s)
through key(s).
@[code]
amap = { 'abc' => 123, 'def' => 456, 'ghi' => 789 }

value  = amap[ 'abc' ];
submap = amap[ 'abc' : 'def' ];
@[code]






@[subsubsection]
Tuples
@[subsubsection]

Tuple is a very handy type, which can be used to hold a fixed number of items,
with type information recorded for each of them.
In a tuple, each item can have a name, which can be used to access
the item as field.
They can be created in similar ways as creating lists and maps,
but use @[green]()@[green] instead.
@[code]
tup1 = ( 123, 'abc' )               # tuple with unnamed items;
tup2 = ( index => 123, 'abc' )      # the first item is named as "index";
tup3 = tuple{ 123, name => 'abc' }  # the second item is named as "name";
@[code]

Each item of a tuple can be accessed using its index or field (item name).
New tuples can be created from other tuples by slicing.
@[code]
tup = ( index => 123, 'abc', [1,2,3] )

id = tup[0]
id = tup.index
tup.index = 456

tup2 = tup[:1]  # ( index => 123, 'abc' )
@[code]




@[subsection]
Control Structures
@[subsection]



@[subsection]
Routines (Functions)
@[subsection]



@[subsection]
Classes
@[subsection]



@[subsection]
Error Handling
@[subsection]


@[text]
