load help;

@[name]
dao.class
@[name]

@[title]
Class for Object-Oriented Programming
@[title]


@[text]
A @[green]class@[green] is a user-defined data structure consisting data fields and
member methods, which define the states and behaviours for the instances of the class.
It is one of the basic building blocks for object-orient programming.
@[text]




@[name]
dao.class.definition
@[name]

@[title]
Definition
@[title]


@[text]
Classes are defined using the @[green]class@[green] keyword, followed
by a class name and base/parent classes if any, and then the class body.
The following is the simplest class:
@[code]
class SimplestClass
{
}
@[code]
which has no base classes and contains no member fields.
In order for the class to have meaningful use,
it must contains some fields to define the states or behavior
of the class or its instance.


@[subsection]
Member Data Field
@[subsection]


Class supports three types data of fields:
@[list]
--@[green]constant@[green]: declared with keyword @[green]const@[green];
--@[green]static variable@[green]: declared with keyword @[green]static@[green];
--@[green]instance variable@[green]: declared with keyword @[green]var@[green];
@[list]
Such fields can be declared with or without explicit types,
and with or without default or initialization values,
in the same way as specifying types and/or default values for function parameters.
For example, the following can be used for instance variables,
@[code]
var variable;
var variable = init_value;
var variable : typename;
var variable : typename = init_value;
@[code]


@[subsection]
Member Method Field
@[subsection]

Dao class supports multiple type of member methods such as
constructor, static method, instance method and virtual method, as well as
methods for overloaded operators.


Class methods must be declared with keyword @[green]routine@[green] 
(or its alias keywords @[green]function@[green] or @[green]sub@[green])
for constructors and normal methods, or keyword @[green]operator@[green]
for operator overloading.


The access of class fields and methods can be restricted by three permission keywords:
@[list]
--@[green]public@[green]: publically accessible without restriction;
--@[green]protected@[green]: accessible from the class and its derived classes;
--@[green]private@[green]: only accessible from the class;
@[list]


@[subsection]
Class Instance
@[subsection]

The following is a simple class without a constructor:
@[code]
class Contact
{
	const description = 'This is a class for contact information'
	var   name = 'Nobody'
	var   address = 'Nowhere'

	routine Show(){ io.writeln( name, 'lives at', address ) }
}
@[code]
There are two ways to create instances of such simple classes:
@[list]
-- Call the default constructor which will initialize the instance variables
   with their default values:
   @[code]
   obj = Contact()
   @[code]
-- Enumerate the values of the instance variables:
   @[code]
   obj = Contact{ 'Mike', '123 Main Street' }
   @[code]
   Field names can be specified for the values, so that these values can appear
   in arbitrary order:
   @[code]
   obj = Contact{ address => '123 Main Street', name => 'Mike' }
   @[code]
   Please note, only simple classes without base classes and explicit constructors
   can use this kind of instance construction.
@[list]



@[subsection]
Class Constructor
@[subsection]

In a class, the methods with the same name as the class itself
are considerred as class constructors.
When the class name is used for a function call,
a class instance will be created and then the appropriate constructor
will be invoked to initialize the instance.
Here is the same class as above, but with a constructor:
@[code]
class Contact
{
	const description = 'This is a class for contact information'
	var   name = 'Nobody'
	var   address = 'Nowhere'

	routine Contact( name : string, address = 'Unknown' ){
		self.name = name
		self.address = address
	}

	routine Show(){ io.writeln( name, 'lives at', address ) }
}
@[code]
Now calling the constructor is the only way to create 
an instance of @[green]Contact@[green]:
@[code]
obj = Contact( 'Mike', '123 Main Street' )
@[code]


Class constructors can be overloaded in the same way as normal functions:
@[code]
class Contact
{
	const description = 'This is a class for contact information'
	var   name = 'Nobody'
	var   address = 'Nowhere'

	routine Contact( name : string, address = 'Unknown' ){
		self.name = name
		self.address = address
	}
	routine Contact( another : Contact ){
		name = another.name
		address = another.address
	}

	routine Show(){ io.writeln( name, 'lives at', address ) }
}
@[code]


@[subsection]
Static Method
@[subsection]

Static methods can be defined by specifying the @[green]static@[green] keyword
before the @[green]routine@[green] keyword.
Such method can be invoked without class instance, for this, they are not allowed
to use class instance variables.
@[code]
class Klass
{
	var id = 123
	static info = 'Klass'
	static routine StaticMethod(){ id = 1 }  # Wrong;
	static routine StaticMethod(){ io.writeln( info ) }  # Correct;
}
obj = Klass::StaticMethod()
@[code]



@[text]




@[name]
dao.class.inheritance
@[name]

@[title]
Inheritance
@[title]


@[text]

In Dao, new classes can be derived from existing classes (and/or C data types)
to inherit their functionalities and to establish is-a relationship between objects.
When a class A is derived from another class B, class A is usually referred to as
a child, or derived, or sub- class, and the class B is ussually referred to as
a parent or base class.


To derive one class from another, the base class must be placed after
the class name of the derived one separated by a colon.
If there are multiple base classes, they must be separated from each other
using commas.


Here is a simple example,
@[code]
class Base
{
	var id = 0

	routine Base( i = 0 ){ id = i }
}
class Sub : Base
{
	var value = 'abc'
}
obj = Sub()
@[code]
In this example, an instance of the derived class is created by calling its
implicit default constructor, which will call an constructor (either implicit
or explicit) of the derived class that accepts no parameters.


When defining a constructor of a derived class, the constructor of a base
class can be called explicitly, by placing the call right after
the constructor signature of the derived on separated by a colon.
The call to a base constructor can only accept the parameters 
(or the @[green]self@[green] variable) of 
the constructor of the derived class.
@[code]
class Sub : Base
{
	var value = 'abc'

	routine Sub( v = 'ABC', i = 3 ) : Base( i ) { value = v }
}
@[code]


Like in C++, Dao supports virtual functions which are defined by specifying
the @[green]virtual@[green] before the @[green]routine@[green] keyword.
@[code]
class Base
{
	var id = 0

	virtual routine VirtMeth(){ io.writeln( 'Base::VirtMeth()' ) }
	routine NormMeth(){ VirtMeth() }
}
class Sub : Base
{
	var value = 'abc'
	routine VirtMeth(){ io.writeln( 'Sub::VirtMeth()' ) }
}
o : Base = Sub()
o.NormMeth() # prints: Sub::VirtMeth()
@[code]


@[text]






@[name]
dao.class.operator
@[name]

@[title]
Operator Overloading
@[title]


@[text]

Class instances can be used in operations in a way similar to those
of built-in types, if the classes define methods to overload relevant operators.


Basic arithmetic operators are also supported for overloading.
For example, addition operator can be supported for a class by defining
a @[green]operator+@[green] method in the following class,
@[code]
class Integer
{
	var value = 0

	routine Integer( val = 0 ){ value = val }

	static operator +( A : Integer, B : Integer ){
		io.writeln( 'Integer + Integer' );
		return Integer( A.value + B.value );
	}
}
I1 = Integer( 123 )
I2 = Integer( 456 )
I3 = I1 + I2
@[code]

Operation for accessing member fields can also be redefined
as overloaded operator @[green]operator .field_name@[green]
and @[green]operator .field_name=@[green]:
@[code]
class Integer
{
	private
	var value = 0

	public
	routine Integer( val = 0 ){ value = val }

	operator .value(){ io.writeln( 'get value' ) }
	operator .value=( v : int ){ value = v; io.writeln( 'get value' ) }
}
I = Integer( 123 )
v = I.value
I.value = 456
@[code]


Some classes may behavior like containers and have members
that can be accessed using an index or a key.
To support member accessing using an index or key,
such class can overload operator @[green][]@[green] and @[green][]=@[green]
@[code]
class IntList
{
	var ints = {}

	routine Append( value : int ){ ints.append( value ) }
	operator []( index : int ){ return ints[index] }
	operator []=( value :int, index : int ){ ints[index] = value }
}
ilist = IntList()
ilist.Append( 123 )
ilist.Append( 456 )
ilist[0] = 789
io.writeln( ilist[0] )
@[code]


TODO: cast

@[text]


#{
In order to avoid creating new class instance whenever such addition operation
is performed, one can define another addition method that can be used when
the instance created by this operation is a temporary object and can be reused.
This method will take the reusable temporary object as the first parameter,
@[code]
class Integer
{
	var value = 0

	routine Integer( val = 0 ){ value = val }

	static operator +( A : Integer, B : Integer ){
		io.writeln( 'Integer + Integer' );
		return Integer( A.value + B.value );
	}
	static operator +( C : Integer, A : Integer, B : Integer ){
		io.writeln( 'Integer = Integer + Integer' );
		C.value = A.value + B.value;
		return C;
	}
}
I1 = Integer( 123 )
I2 = Integer( 456 )
for( i = 1 : 3 ) I3 = I1 + I2
@[code]
#}






@[name]
dao.class.mixin
@[name]

@[title]
Mixin Class (New)
@[title]


@[text]
(New in the latest devel release and online version)


Classes to be used as mixins can be specified in a pair of brackets
following the class name. Only classes without parent classes can
be used as mixins.

@[code]
class Base
{
	var value = 456
	routine Meth2(){ io.writeln( self, value ) }
}

class Mixin ( Base )
{
	var index = 123

	routine Meth(){ io.writeln( self, index, value ) }
	routine Meth2( a : string ){ io.writeln( self, index, value, a ) }
}

#
# The "Base" class will be presented only once in "Klass":
#
class Klass ( Base, Mixin )
{
	var index = 123456
	routine Meth2( a : int ){ io.writeln( self, index, value, a ) }
}

k = Klass()

io.writeln( k.index )

k.Meth()
k.Meth2()
k.Meth2( 'abc' )
k.Meth2( 789 )
@[code]

@[text]






@[name]
dao.class.decorator
@[name]

@[title]
Class Decorator (New)
@[title]


@[text]
(New in the latest devel release and online version)


When a class is used as a mixin class in another class (host),
the decorator methods of the mixin will be applied to the methods
of the host class, if the names of the decorators are started
(excluding the '@') or ended with a underscore. Such names
are interpreted as the following patterns:
@[list]
== The non-underscore-containing substring following the starting
   underscore is considered as a prefix that a method name must
   has, as a precondition that the method can be applied with
   the decorator;

   Example:
   @[list(sub)]
   -- "_abc", "_abc_" and "any_abc_" define "abc" as the prefix;
   -- "__" and "__any" define an empty string as prefix,
       which can match to any method name.
   @[list(sub)]
== The non-underscore-containing substring preceding the ending
   underscore is considered as a suffix that a method name must
   has, as a precondition that the method can be applied with
   the decorator;

   Example:
   @[list(sub)]
   -- "abc_", "_abc_" and "_abc_any" define "abc" as the suffix;
   -- "__" and "any__" define an empty string as suffix,
       which can match to any method name.
   @[list(sub)]
== If the prefix substring and the suffixing substring of a decorator
   name are the same substring (not merely the same), only the methods
   with names that are the same as the prefix (suffix) could be applied
   with this decorator. 

   Example:
   @[list(sub)]
   -- "_abc_" define "abc" as both the prefix and the suffix,
       so it can only be matched to method name equal to it.
       But "_abc_abc_" can match to any method names starts
       with "abc" and ends with "abc";
   -- "__" and "__any__" define an empty string as both prefix and suffix,
       so it can match to any method name;
   @[list(sub)]
@[list]

When multiple mixins are used in a host class, the decorators of the
first mixin are applied the last. An the first decorator of the same
decorator is also applied the last as well.

@[code]
class Header
{
	static routine @__Delimiter__( meth : routine ){
		io.writeln( '=======================' )
		return meth( __args__, ... )
	}
	routine @__Delimiter__( meth : routine ){
		io.writeln( '-----------------------' )
		return meth( __args__, ... )
	}
}
class Decorator
{
	var value = 654321

	routine @_Test_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Test_()', value )
		meth( __args__, ... );
	}
	routine @_Prefix( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Prefix()' )
		meth( __args__, ... );
	}
	routine @Suffix_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::Suffix_()' )
		meth( __args__, ... );
	}
	routine @_Prefix_Suffix_( meth :routine<self:Decorator> ){
		io.writeln( 'Decorator::_Prefix_Suffix_()' )
		meth( __args__, ... );
	}
}

class MyClass ( Header, Decorator )
{
	routine Test(){
		io.writeln( 'MyClass::Test()' )
	}
	routine PrefixTest(){
		io.writeln( 'MyClass::PrefixTest()' )
	}
	routine TestSuffix(){
		io.writeln( 'MyClass::TestSuffix()' )
	}
	routine PrefixTestSuffix(){
		io.writeln( 'MyClass::PrefixTestSuffix()' )
	}
}

obj = MyClass()
obj.Test()
obj.PrefixTest()
obj.TestSuffix()
obj.PrefixTestSuffix()
@[code]
@[text]






@[name]
dao.class.aspect
@[name]

@[title]
Aspect Class (New)
@[title]


@[text]
(New in the latest devel release and online version)


In Dao, a class can be effectly used as an aspect for AOP,
if the class name is named according some simple affix rules.
Please see @[node]dao.class.mixin@[node] for such affix rules.


The fields of such class will be automatically injected to
normal classes selected according to the affix rules, and
the decorators defined in such aspect class are automatically
applied to the methods (selected according to the same affix
rules) of the normal classes.

@[code]
class __AspectForAnyClass__
{
	var injected = {}

	routine __AspectForAnyClass__(){
		io.writeln( 'In __AspectForAnyClass__:' );
		injected = { 1, 2, 3 }
	}

	# This decorator will also be applied to the default constructors:
	routine @__DecoratorForAnyMethod__( meth : routine ){
		io.writeln( 'In __DecoratorForAnyMethod__:', std.about(meth) )
		io.writeln( injected )
		return meth( __args__, ... )
	}
}

# For classes with names prefixed with My:
class _My_AspectForMyClasses
{
	routine @Method_( meth : routine ){
		io.writeln( 'In _My_AspectForMyClasses::Method_:', std.about(meth) )
		return meth( __args__, ... )
	}
}

class MyClass
{
	routine Method(){ io.writeln( 'MyClass::Method()' ) }
}

k = MyClass()  # Invoke the default constructor of Klass;
k.Method()
@[code]
@[text]




@[name]
dao.class.dynamic
@[name]

@[title]
Dynamic Class (Obsolete; Remove since dao-2.0-devel-2013-06-09)
@[title]



@[name]
dao.interface
@[name]

@[title]
Abstract Interface
@[title]


@[text]
Abstract interface is a type that describes how an object can be used,
by specifying what methods and overloaded operators the object can support.
An object is compatible (matching) to an interface type,
if only if the object supports all the methods and operators that are
specified by the interface.
Interface is an abstract type, since no instance can be created from an interface,
also all the methods of an interface are abstract without implementation.


Here is a simple interface that contains a size checking method,
@[code]
interface HasSize
{
	routine size()=>int
}
@[code]
Now we can define a function that can take a parameter of any object that is
compatible to this interface,
@[code]
routine PrintSize( object: HasSize )
{
	io.writeln( object.size() )
}
@[code]
Then this function can be called upon types such as @[green]string@[green],
@[green]list@[green] or @[green]map@[green] etc.
@[code]
PrintSize( 'hello world' )
PrintSize( { 1, 2, 3 } );
@[code]


Interface supports inheritance in the same way as class does,
@[code]
interface Resizable : HasSize
{
	routine resize( size :int )
}
@[code]
Similarly,
@[code]
routine Resize( object: Resizable, size: int )
{
	io.writeln( 'old size:', object.size() )
	io.writeln( 'new size:', size )
	object.resize( size )
}

ls = {}
Resize( ls, 5 )
io.writeln( ls )
@[code]


Interface also supports operator overloading, however, built-in operators
for built-in types cannot be checked against an interface, because they
are not implemented as methods. So interfaces are normally more useful
with class instances and wrapped C/C++ types.


Interfaces with the same set of abstract methods are interchangeable,
@[code]
interface HasSize2
{
	routine size()=>int
}
routine PrintSize2( object: HasSize2 )
{
	o :HasSize = object; # assign an object of "HasSize2" to a variable of "HasSize";
	io.writeln( object.size() )
}
PrintSize2( {} );
@[code]


Just for testing,
@[code(test)]
interface HasSize
{
	routine size()=>int
}
routine PrintSize( object: HasSize )
{
	io.writeln( object.size() )
}
PrintSize( 'hello world' )
PrintSize( { 1, 2, 3 } );

interface Resizable : HasSize
{
	routine resize( size :int )
}
routine Resize( object: Resizable, size: int )
{
	io.writeln( 'old size:', object.size() )
	io.writeln( 'new size:', size )
	object.resize( size )
}

ls = {}
Resize( ls, 5 )
io.writeln( ls )



interface HasSize2
{
	routine size()=>int
}
routine PrintSize2( object: HasSize2 )
{
	o :HasSize = object;
	io.writeln( object.size() )
}
PrintSize2( {} );
@[code(test)]



@[text]




@[name]
dao.metafield
@[name]

@[title]
Meta Field (Obsolete; Remove since dao-2.0-devel-2013-06-09)
@[title]


@[text]
@[text]

#{
Meta fields are supported for all data types.
Such fields can be set and got by meta field operator @[green]->@[green].
@[code]
obj = 123
obj->name = 'abc'
name = obj->name
@[code]
Meta fields do not subject to static type checking,
and do not interfere with the normal fields.


For a map with string keys, its value can also be accessed
using the meta field operator @[green]->@[green],
@[code]
amap = { 'name' => 'Test' }
value = amap->name

amap->color = 'Green'  # insert (color, Green);
@[code]


A special meta field @[green]__proto__@[green] can be set to be a map,
for delegated field lookup.
@[code]
a = { 'name' => 'Test' }

a->meth = routine( self : map<string,string> )
{
  for( it in self ) io.writeln( it )
}
a->meth();

c = { 'index' => 123 }
c->__proto__ = a;
io.writeln( c->name, c );

class Test{}
t = Test();

t->value = 123;
io.writeln( t->value );

t->__proto__ = c;

io.writeln( t->name, t->index );
@[code]
#}

