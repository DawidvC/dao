load help;

@[name]
daovm.architecture
@[name]

@[title]
The architecture of the Dao Virtual Machine
@[title]




@[name]
daovm.architecture.vmspace
@[name]

@[title]
Virtual Machine Space
@[title]


@[name]
daovm.architecture.namespace
@[name]

@[title]
Namespace
@[title]


@[name]
daovm.architecture.class
@[name]

@[title]
Class
@[title]


@[name]
daovm.architecture.routine
@[name]

@[title]
Routine
@[title]


@[name]
daovm.architecture.process
@[name]

@[title]
Virutal Machine Process
@[title]


@[name]
daovm.architecture.instruction
@[name]

@[title]
Virtual Machine Instructions
@[title]





@[name]
daovm.architecture.bytecode
@[name]

@[title]
Binary Bytecode Format
@[title]

@[text]


This document contains specifications of the bytecode format for Dao virtual machine.
In this bytecode format, integers are always stored in big endian.


In the following specifications or examples, each byte is represented by
two hexadecimal digits, unless it is quoted by quotation marks.


Data type used in the specification:
@[code(dao)]
type int8       # one byte signed integer;
type uint8      # one byte unsigned integer;
type uint16     # two byte unsigned integer;
type uint32     # four byte unsigned integer;
type int        # four or eight byte integer;
type double     # IEEE 754 double;

def short_string
{
	uint16      # string length;
	int8[]      # character array;
}
@[code(dao)]


A Dao binary bytecode file will contain the following sections:
@[list]
==@[green]Header@[green]: basic information for the format;
==@[green]Source@[green]: path and file name of the source;
==@[green]Modules@[green]: modules need to be loaded;
==@[green]Identifiers@[green]: identifiers used in the file;
==@[green]Declarations@[green]: forward declaration of routines and classes etc.;
==@[green]Types@[green]: declaration of types;
==@[green]Values@[green]: all the values used in the file;
==@[green]Global Constants@[green]: global constants;
==@[green]Global Variables@[green]: global variables;
==@[green]Global Types@[green]: global types;
==@[green]Interfaces@[green]: interface definitions;
==@[green]Classes@[green]: class definitions;
==@[green]Routines@[green]: routine definitions;
@[list]


@[section]
Header
@[section]

Dao binary bytecode file begins with a header of 16 bytes consisting 
of the following parts:
@[code(dao)]
def Header 
{
	uint8       # Start of Header (SOH), 0x1;
	uint8       # 0x44, namely 'D';
	uint8       # 0x61, namely 'a';
	uint8       # 0x6F, namely 'o';
	uint8       # major version number, 0x1;
	uint8       # minor version number, 0x2;
	uint8       # Carriage Return (CR), 0x0D;
	uint8       # Line Feed (LF), 0x0A;
	uint8       # format version, 0x0 for the official one;
	uint8       # size of integer type, default 0x4;
	uint8[6]    # six reserved bytes;
}
@[code(dao)]
Example,
@[code(dao)]
01 44 61 6F 01 02 0D 0A    # 8 bytes, signature for Dao 1.2;
00                         # uint8, format version: zero for official;
04                         # uint8, size of int: default 4;
00 00 00 00 00 00          # 6 byte, reserved;
@[code(dao)]
Regardless the size of integer, the bytecode should be loadable on both
32-bit and 64-bit Dao Virtual Machines, as long as the integers used
in the bytecode file do not overflow.



@[section]
Source
@[section]

The source file name (possibly including the path) is stored immediately after
the header as a @[green]short_string@[green]:
@[code(dao)]
def Source
{
	short_string  # source name;
}
@[code(dao)]
Example,
@[code(dao)]
00 09            # uint16, source name length in bytes;
"test.dao"       # variable number of bytes;
@[code(dao)]



@[section]
Modules
@[section]

This section lists the modules that are needed for the current codes.
They will be loaded in order to properly decode the rest of the bytecode file.
@[code(dao)]
def Modules
{
	uint16          # number of modules;
	short_string[]  # list of module file names;
}
@[code(dao)]
Example,
@[code(dao)]
00 02            # uint16, number of loaded modules;

00 0C            # uint16, length of the first module name/path;
"module1.dao"    # variable number of bytes;

00 0C            # uint16, length of the second module name/path;
"module2.dao"    # variable number of bytes;
@[code(dao)]



@[section]
Identifiers
@[section]

Identifiers are referenced by 1-base indices in this section,
such reference numbers are encoded in 16-bit unsigned integers.
Zero 0x0000 is used to indicate non-existing identifier,
which can be used to declare constants or variables which
occupy slots in the constant or variable arrays without names.

@[code(dao)]
def Identifiers
{
	uint16          # number of identifiers;
	short_string[]  # list of identifier strings;
}
@[code(dao)]
Example,
@[code(dao)]
00 05           # uint16, number of identifiers;

00 05           # uint16, identifier length;
"true"        # variable number of bytes;

00 06           # uint16, identifier length;
"false"       # variable number of bytes;

00 06           # uint16, identifier length;
"short"       # variable number of bytes;

00 09           # uint16, identifier length;
"Drawable"    # variable number of bytes;

00 09           # uint16, identifier length;
"DrawLine"    # variable number of bytes;

00 06           # uint16, identifier length;
"Klass"       # variable number of bytes;

00 05           # uint16, identifier length;
"Test"        # variable number of bytes;
...
@[code(dao)]


@[section]
Declarations
@[section]


Forward declarations of classes, interfaces, routines, ctype and namespace etc.
Each declaration is referenced by an unsigned 16-bit integer,
with 0x0000 reserved for the current namespace.
Scope objects listed in this section should be referenced by the 1-base index in this section.


Each declaration entry has the following fields:
@[code(dao)]
def ScopingObject
{
	uint8       # object type (internal type ID);
	uint8       # flag (0x0 for creating, or 0x1 for searching);
	uint16      # identifier reference number for the scope name;
}
def ScopingObjects 
{
	uint16           # number of declarations;
	ScopingObject[]  # list of declarations;
}
@[code(dao)]

Example,
@[code(dao)]
00 03           # uint16, number of declarations;

0E              # uint8, object type (internal type ID for class);
00              # uint8, new class to be created;
00 06           # uint16, identifier reference number for the class name;

0E              # uint8, object type (internal type ID for class);
00              # uint8, new nested class to be created;
00 07           # uint16, identifier reference number for the class name;

0F              # uint8, object type (internal type ID for ctype);
01              # uint8, ctype to be found in loaded modules;
00 08           # uint16, identifier reference number for the ctype name;
@[code(dao)]


@[section]
Types
@[section]


The type section will declare a list of types
which can be referenced by their 1-based 16-bit integer indices in this section.
Zero is used to indicate a unspecified type.
Each type is declared with one byte for its internal type ID,
and two bytes of identifier reference number for its type name, 
followed by addition information.
A zero identifier reference number indicates the type has default
name that will be constructed from the type information.


Type declaration formats:
@[code(dao)]
# Core types: none, integer, float, ..., string:
def CoreType 
{
	uint8       # type id (DAO_NONE, DAO_INTEGER, ...);
	uint16      # identifier reference number to the type name;
}

# Enum type:
def EnumType 
{
	uint8       # type id (DAO_ENUM);
	uint16      # identifier reference number to the type name;
	uint8       # sub type, 0 for normal enums, 1 for flags;
	uint16      # number of symbols;
	{
		uint16  # identifier reference number to the symbol;
		uint32  # values associated with the symbol;
	}[]         # list of symbols;
}

# Array, List, Map, Tuple, Variant type:
def CollectionOrVariantType
{
	uint8       # type id (DAO_ARRAY, DAO_LIST, ...);
	uint16      # identifier reference number to the type name;
	uint16      # number of item types;
	uint16[]    # list of item types: type reference numbers;
}

# Value type:
def ValueType
{
	uint8       # type id (DAO_VALTYPE);
	uint16      # identifier reference number to the type name;
	uint32      # value reference number for the value;
}

# Named parameter: name:type or name=type
def NameParamType
{
	uint8       # type id (DAO_PAR_NAMED or DAO_PAR_DEFAULT);
	uint16      # identifier reference number to the type name;
	uint16      # identifier reference number to the parameter name;
	uint16      # type reference number;
}

# Type holder type:
def TypeHolderType
{
	uint8       # type id (DAO_THT);
	uint16      # identifier reference number to the type name;
}

# Routine types:
def RoutineType
{
	uint8       # type id (DAO_ROUTINE);
	uint16      # identifier reference number to the type name;
	uint16      # type reference number to the return type;
	uint16      # number of item types;
	uint16[]    # list of item types: type reference numbers;
}

# Interface type:
def InterfaceType
{
	uint8       # type id (DAO_CLASS);
	uint16      # identifier reference number to the type name;
	uint16      # declaration reference number for the interface;
}

# Class type:
def ClassType
{
	uint8       # type id (DAO_CLASS);
	uint16      # identifier reference number to the type name;
	uint16      # declaration reference number for the class;
}

# Class instance type:
def ClassInstanceType
{
	uint8       # type id (DAO_OBJECT);
	uint16      # identifier reference number to the type name;
	uint16      # declaration reference number for the class;
}

# Ctype type:
def CtypeType
{
	uint8       # type id (DAO_CTYPE);
	uint16      # identifier reference number to the type name;
	uint16      # declaration reference number for the ctype;
}

# Cdata type:
def CdataType
{
	uint8       # type id (DAO_CDATA);
	uint16      # identifier reference number to the type name;
	uint16      # declaration reference number for the ctype;
}

# Type type:
def TypeType
{
	uint8       # type id (DAO_TYPE);
	uint16      # identifier reference number to the type name;
	uint16      # type reference number to the type;
}

# Future value type:
def FutureValueType 
{
	uint8       # type id (DAO_FUTURE);
	uint16      # identifier reference number to the type name;
	uint16      # type reference number to the value type;
}
@[code(dao)]


Example,
@[code(dao)]
00 06           # uint16, number of types: 0x6;
02 00 00        # uint8 + uint16, float type with default name;
06 00 00        # uint8 + uint16, string type with default name;
07              # uint8, enum type
00 02           # uint16, type name;
00              # uint8, non-flag type: enum<true,false>;
00 02           # uint16, number of items: 2;
00 01           # uint16, identifier reference number for "true";
00 02           # uint16, identifier reference number for "false";
08              # uint8, array type; array<float>;
00 03           # uint16, type name;
00 01           # uint16, number of items: 1;
00 02           # uint16, type reference number for float;
@[code(dao)]



@[section]
Values
@[section]

All values are stored with one byte of type ID followed by additional data.
Values are referenced by their 1-base indices in this section.
Value reference numbers are 32-bit unsigned integer.
Zero is reserved for a NULL value.


Value formats:
@[code(dao)]
# none:
def NoneValue
{
	uint8       # type ID (0x00, DAO_NONE);
}

# int:
def IntValue 
{   
   uint8        # type ID (0x01, DAO_INTEGER);
   int          # integer value;
}

# float:
def FloatValue
{   
   uint8        # type ID (0x02, DAO_FLOAT);
   double       # double value;
}

# double:
def DoubleValue
{   
   uint8        # type ID (0x03, DAO_DOUBLE);
   double       # double value;
}

# complex:
def ComplexValue
{   
   uint8        # type ID (0x04, DAO_COMPLEX);
   double       # double value, real part;
   double       # double value, imaginary part;
}

# long:
def LongValue
{   
   uint8        # type ID (0x05, DAO_LONG);
   uint8        # sign, 0 for positive, 1 for negative;
   int          # number of 256-base digits;
   uint8[]      # list of digits;
}

# string:
def StringValue
{   
   uint8        # type ID (0x06, DAO_STRING);
   uint8        # char type (0 for WCS, 1 for MBS);
   Variable number of bytes: list of characters (uint8 or uint32);
}

# enum:
def EnumValue
{
   uint8        # type ID (0x07, DAO_ENUM);
   uint16       # type reference number;
   uint32       # value;
}

# array:
def ArrayValue
{
   uint8        # type ID (0x08, DAO_ARRAY);
   uint8        # numeric type ID (for int, float, double or complex);
   int          # total number of elements;
   uint16       # number of dimensions;
   int[]        # list of dimension sizes (int);
   (int|float|double|complex)[]  # list of elements;
}

# list:
def ListValue
{
   uint8        # type ID (0x09, DAO_LIST);
   uint16       # type reference number;
   int          # number of items;
   uint32[]     # list of value reference numbers;
}

# map:
def MapValue
{
   uint8        # type ID (0x0A, DAO_MAP);
   uint8        # subtype (0x0 for map; 0x1 for hash);
   uint16       # type reference number;
   int          # number of items;
   uint32[]     # list of value reference numbers;
}

# tuple:
def TupleValue
{
   uint8        # type ID (0x0B, DAO_ARRAY);
   uint16       # type reference number;
   int          # number of items;
   uint32[]     # list of value reference numbers;
}

# Class instance:
# Complete instance:
def CompleteClassInstanceValue 
{
   uint8        # type ID (0x0C, DAO_OBJECT);
   uint8        # partial or complete (0x0 for complete and 0x1 for partial);
   uint16       # type reference number;

   uint16       # number of values;
   uint16[]     # list of value reference numbers;
}
# Partial instance is an instance embedded in another:
def PartialClassInstanceValue 
{
   uint8        # type ID (0x0C, DAO_OBJECT);
   uint8        # partial or complete (0x0 for complete and 0x1 for partial);
   uint16       # type reference number;

   uint16       # value offset;
   uint16       # value reference number for its host object;
}

# Routine:
def RoutineValue
{
   uint8        # type ID (0x11, DAO_ROUTINE);
   uint16       # declaration reference number for the routine;
   uint16       # type reference number for the routine type;
}

# Class, ctype, interface and namespace:
def ClassCtypeInterfaceNamespaceValue
{
   uint8        # type ID (DAO_ROUTINE, DAO_CLASS, ...);
   uint16       # declaration reference number;
}

# Type value:
def TypeValue
{
   uint8        # type ID (DAO_TYPE);
   uint16       # type reference number for the type;
}

# Imported value from loaded module:
def ExternalValue
{
	uint8       # 0xFF;
	uint32      # lookup index for values from loaded modules;
}


def Values
{
	uint32      # number of values;
	[]          # list of values;
}
@[code(dao)]


Example,
@[code(dao)]
00 00 00 23     # uint32, number of values: 0x23;
01              # uint8, value type id: integer;
00 15 23 12     # int, value: 0x152312;
02              # uint8, value type id: float;
00 00 00...     # double;
03              # uint8, value type id: double;
00 00 00...     # double;
04              # uint8, value type id: complex;
00 00 00...     # double;
00 00 00...     # double;
05              # uint8, value type id: long;
00 00 00 30     # int, length: 0x30;
...             # 0x30 bytes;
06              # uint8, value type id: string;
01              # uint8, string type: 0, WCS; 1, MBS;
00 00 00 30     # int, length: 0x30;
...             # 0x30 bytes;
07              # uint8, value type id: enum;
01 02           # uint16, type reference number for enum<true,false>;
00 00 00 02     # uint32, value: 0x2;
@[code(dao)]




@[section]
Global Constants
@[section]

Global constants are listed in the order of their declarations in the original
source file. Each constant is encoded in the following format,
@[code(dao)]
def Constant
{
	uint16      # identifier reference number for the constant name;
                # 0x0000 declares a constant without name;

	uint8       # permission (0: public; 1: protected: 2: private);
	uint32      # value reference number for the constant;
}

def GlobalConstants
{
	uint16      # number of global constants;
	Constant[]  # list of constants;
}
@[code(dao)]


Example,
@[code(dao)]
00 12           # uint16, number of global constants: 0x12;
00 10           # uint16, identifier reference number for the constant name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the constant;
00 15           # uint16, identifier reference number for the constant name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the constant;
...
@[code(dao)]


@[section]
Global Variables
@[section]

Global variables are listed in the order of their declarations in the original
source file. Each variable is encoded in the following format,
@[code(dao)]
def Variable
{
	uint16      # identifier reference number for the variable name;
	            # 0x0000 will declare a variable without name;

	uint8       # permission (0: public; 1: protected: 2: private);
	uint16      # type reference number for the variable;
	            # 0x0000 can be used for variables without explicit types;

	uint32      # value reference number for the initial or default value;
	            # 0x00000000 can be used for variables without such value;
}

def GlobalVariables
{
	uint16      # number of global variables;
	Variable[]  # list of variables;
}
@[code(dao)]


Example,
@[code(dao)]
00 23           # uint16, number of global variables: 0x23;
00 11           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 03           # uint16, type reference number for the variable;
00 00 00 02     # uint32, value reference number for the variable;
00 14           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 03           # uint16, type reference number for the variable;
00 00 00 05     # uint32, value reference number for the variable;
...
@[code(dao)]




@[section]
Global Types
@[section]

Each global type declaration is encoded in the following format,
@[code(dao)]
def Type
{
	uint16      # identifier reference number for the type name;
	uint16      # type reference number for the type;
}

def GlobalTypes
{
	uint16      # number of global types;
	Type[]      # list of types;
}
@[code(dao)]





@[section]
Interfaces
@[section]


Each interface is declared with the following fields:
@[code(dao)]
def Interface 
{
	uint16      # declaration reference number to the interface;
	uint16      # number of parent interfaces;
	uint16[]    # list of declaration reference numbers to parents;
	uint16      # number of abstract methods;
	uint32[]    # list of value reference numbers to the methods;
}

def Interfaces 
{
	uint16       # number of interfaces;
	Interface[]  # list of interfaces;
}
@[code(dao)]


Example,
@[code(dao)]
00 01           # uint16: number of interfaces;
00 09           # uint16: declaration reference number to the interface;
00 01           # uint16: number of parent interfaces;
00 08           # uint16: declaration reference number to the parent interface;
00 02           # uint16: number of abstract methods;
00 00 00 09     # uint32: value reference number to the abstract method;
00 00 00 11     # uint32: value reference number to the abstract method;
@[code(dao)]


@[section]
Classes
@[section]


Each class is declared in the following format:
@[code(dao)]
def Class 
{
	uint16      # declaration reference number to the class;
	uint16      # number of parent classs;
	uint16[]    # list of declaration reference numbers to the parents;
	uint16      # number of constants (including methods);
	Constant[]  # list of constants in the same format as global constants;
	uint16      # number of static varaibles;
	Variable[]  # list of variables in the same format as global variables;
	uint16      # number of instance varaibles;
	Variable[]  # list of variables in the same format as global variables;
	uint16      # number of types in the class scope;
	Type[]      # list of types;
}

def Classes 
{
	uint16      # number of classes;
	Class[]     # list of classes;
}
@[code(dao)]


Example,
@[code(dao)]
00 01           # uint16, number of classes: 0x1;
00 09           # uint16: declaration reference number to the class;
00 01           # uint16: number of parent classs;
00 08           # uint16: declaration reference number to the parent class;
00 02           # uint16: number of constants;
00 10           # uint16, identifier reference number for the constant name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the constant;
00 15           # uint16, identifier reference number for the constant name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the constant;
00 02           # uint16: number of static variables;
00 10           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the variable;
00 15           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the variable;
00 02           # uint16: number of instance variables;
00 10           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the variable;
00 15           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the variable;
@[code(dao)]




@[section]
Routines
@[section]


@[code(dao)]
def Instruction 
{
	uint16      # opcode;
	uint16      # oprand a;
	uint16      # oprand b;
	uint16      # oprand c;
	uint16      # lexical level;
	uint16      # line;
}

def Routine 
{
	uint16      # declaration reference number to the routine;
	uint16      # declaration reference number to the host of the routine;
	uint16      # identifier reference number to the routine name;
	uint16      # type reference number to the routine type;
	uint16      # attributes;
	uint16      # line of definition;
	uint16      # number of local constants;
	uint32[]    # list of value reference numbers for the constants;
	uint16      # number of local variables;
	uint16[]    # list of type reference numbers for the local variable;
	uint16      # number of instructions;
	Instruction[] # list of instructions;
}

def Routines
{
	uint16      # number of routines;
	Routine[]   # list of routines;
}
@[code(dao)]


@[text]
