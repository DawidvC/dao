load help;

@[name]
daovm.architecture
@[name]

@[title]
The architecture of the Dao Virtual Machine
@[title]




@[name]
daovm.architecture.vmspace
@[name]

@[title]
Virtual Machine Space
@[title]


@[name]
daovm.architecture.namespace
@[name]

@[title]
Namespace
@[title]


@[name]
daovm.architecture.class
@[name]

@[title]
Class
@[title]


@[name]
daovm.architecture.routine
@[name]

@[title]
Routine
@[title]


@[name]
daovm.architecture.process
@[name]

@[title]
Virutal Machine Process
@[title]


@[name]
daovm.architecture.instruction
@[name]

@[title]
Virtual Machine Instructions
@[title]





@[name]
daovm.architecture.bytecode
@[name]

@[title]
Binary Bytecode Format
@[title]

@[text]


This document contains specifications of the bytecode format for Dao virtual machine.
In this bytecode format, integers are always stored in big endian.


In the following specifications or examples, each byte is represented by
two hexadecimal digits, unless it is quoted by quotation marks.


Data type used in the specification:
@[code(dao)]
type int8       # one byte signed integer;
type uint8      # one byte unsigned integer;
type uint16     # two byte unsigned integer;
type uint32     # four byte unsigned integer;
type int        # four or eight byte integer;
type double     # IEEE 754 double;

def short_string
{
	uint16      # string length (including the null char at the end);
	int8[]      # array characters terminated by a null charater 0x0;
}
@[code(dao)]


A Dao binary bytecode file will contain the following sections:
@[list]
==@[green]Header@[green]: basic information for the format;
==@[green]Source@[green]: path and file name of the source;
==@[green]Modules@[green]: modules need to be loaded;
==@[green]Identifiers@[green]: identifiers used in the file;
==@[green]Scoping Objects@[green]: forward declaration of routines and classes etc.;
==@[green]Types@[green]: declaration of types;
==@[green]Type Aliases@[green]: declaration of type aliasing;
==@[green]Values@[green]: all the values used in the file;
==@[green]Global Constants@[green]:
==@[green]Global Variables@[green]:
==@[green]Interfaces@[green]:
==@[green]Classes@[green]:
==@[green]Routines@[green]:
@[list]


@[section]
Header
@[section]

Dao binary bytecode file begins with a header of 16 bytes consisting 
of the following parts:
@[code(dao)]
def Header 
{
	uint8       # Start of Header (SOH), 0x1;
	uint8       # 0x44, namely 'D';
	uint8       # 0x61, namely 'a';
	uint8       # 0x6F, namely 'o';
	uint8       # major version number, 0x1;
	uint8       # minor version number, 0x2;
	uint8       # Carriage Return (CR), 0x0D;
	uint8       # Line Feed (LF), 0x0A;
	uint8       # format version, 0x0 for the official one;
	uint8       # size of integer type, default 0x4;
	uint8[6]    # six reserved bytes;
}
@[code(dao)]
Example,
@[code(dao)]
01 44 61 6F 01 02 0D 0A    # 8 bytes, signature for Dao 1.2;
00                         # uint8, format version: zero for official;
04                         # uint8, size of int: default 4;
00 00 00 00 00 00          # 6 byte, reserved;
@[code(dao)]
Regardless the size of integer, the bytecode should be loadable on both
32-bit and 64-bit Dao Virtual Machines, as long as the integers used
in the bytecode file do not overflow.



@[section]
Source
@[section]

The source file name (possibly including the path) is stored immediately after
the header as a @[green]short_string@[green]:
@[code(dao)]
def Source
{
	short_string  # source name;
}
@[code(dao)]
Example,
@[code(dao)]
00 09            # uint16, source name length in bytes;
"test.dao\0"     # variable number of bytes;
@[code(dao)]



@[section]
Modules
@[section]

This section lists the modules that are needed for the current codes.
They will be loaded in order to properly decode the rest of the bytecode file.
@[code(dao)]
def Modules
{
	uint16          # number of modules;
	short_string[]  # list of module file names;
}
@[code(dao)]
Example,
@[code(dao)]
00 02            # uint16, number of loaded modules;

00 0C            # uint16, length of the first module name/path;
"module1.dao\0"  # variable number of bytes;

00 0C            # uint16, length of the second module name/path;
"module2.dao\0"  # variable number of bytes;
@[code(dao)]



@[section]
Identifiers
@[section]

Identifiers are referenced by 1-base indices in this section,
such reference numbers are encoded in 16-bit unsigned integers.
Zero 0x0000 is used to indicate non-existing identifier,
which can be used to declare constants or variables which
occupy slots in the constant or variable arrays without names.

@[code(dao)]
def Identifiers
{
	uint16          # number of identifiers;
	short_string[]  # list of identifier strings;
}
@[code(dao)]
Example,
@[code(dao)]
00 05           # uint16, number of identifiers;

00 05           # uint16, identifier length + 1;
"true\0"        # variable number of bytes;

00 06           # uint16, identifier length + 1;
"false\0"       # variable number of bytes;

00 06           # uint16, identifier length + 1;
"short\0"       # variable number of bytes;

00 09           # uint16, identifier length + 1;
"Drawable\0"    # variable number of bytes;

00 09           # uint16, identifier length + 1;
"DrawLine\0"    # variable number of bytes;

00 06           # uint16, identifier length + 1;
"Klass\0"       # variable number of bytes;

00 05           # uint16, identifier length + 1;
"Test\0"        # variable number of bytes;
...
@[code(dao)]


@[section]
Scoping Objects
@[section]


Forward declarations of scoping objects such as classes, interfaces, routines,
ctype and namespace, and their scoping relationships.
Each scoping object is referenced by an unsigned 16-bit integer,
with 0x0000 reserved for the current top level scoping object (namely, the current namespace).
Scope objects listed in this section should be referenced by the 1-base
index of their declaration in this section.


Each scoping object is declared with the following fields:
@[code(dao)]
def ScopingObject
{
	uint8       # scoping object type (internal type ID);
	uint8       # flag (0x0 for creating, or 0x1 for searching);
	uint16      # identifier reference number for the scope name;
	uint16      # scoping object reference number to the host;
	            # For example, for nested classes, this field can be used to
	            # store the scoping object reference number to outer classes.
}
def ScopingObjects 
{
	uint16           # number of scoping objects;
	ScopingObject[]  # list of scoping objects;
}
@[code(dao)]

Example,
@[code(dao)]
00 03           # uint16, number of scoping objects;

0E              # uint8, scoping object type (internal type ID for class);
00              # uint8, new class to be created;
00 06           # uint16, identifier reference number for the class name;
00 00           # uint16, scoping object reference number to the host;

0E              # uint8, scoping object type (internal type ID for class);
00              # uint8, new nested class to be created;
00 07           # uint16, identifier reference number for the class name;
00 01           # uint16, scoping object reference number to the host;

0F              # uint8, scoping object type (internal type ID for ctype);
01              # uint8, ctype to be found in loaded modules;
00 08           # uint16, identifier reference number for the ctype name;
00 00           # uint16, scoping object reference number to the host;
@[code(dao)]


@[section]
Types
@[section]

All the types are referenced by unsigned short integer (uint16).
The numbers smaller than 256 are all reserved for direct referencing.
Zero is used to indicate unspecified type.
Primitive types and some special types are directly referenced by 
the following reserved numbers:
@[list]
--@[red]0x1@[red]: @[green]integer@[green];
--@[red]0x2@[red]: @[green]float@[green];
--@[red]0x3@[red]: @[green]double@[green];
--@[red]0x4@[red]: @[green]complex@[green];
--@[red]0x5@[red]: @[green]long@[green];
--@[red]0x6@[red]: @[green]string@[green];
--@[red]0x10@[red]: @[green]process@[green];
--@[red]0x11@[red]: @[green]namespace@[green];
--@[red]0x20@[red]: @[green]none@[green];
--@[red]0x21@[red]: @[green]any@[green];
--@[red]0x22@[red]: @[green]?@[green], undefined type;
--@[red]0x40@[red]: @[green]...@[green], variadic parameter;
@[list]


The type section will declare a list of types
which will be referenced by 0xFF plus its 1-based index in this section.
Each type is declared with one byte for its internal type ID,
and two bytes for its declaration scope,
followed by addition information.


Type declaration formats:

@[code(dao)]
# Core types: none, integer, float, ..., string:
def CoreType 
{
	uint8       # type id (DAO_NONE, DAO_INTEGER, ...);
	uint16      # scoping object reference number;
}

# Enum type:
def EnumType 
{
	uint8       # type id (DAO_ENUM);
	uint16      # scoping object reference number;
	uint8       # sub type, 0 for normal enums, 1 for flags;
	uint16      # number of symbols;
	uint16[]    # list of symbols: identifier reference numbers;
}

# Array, List, Map, Tuple, Variant type:
def CollectionOrVariantType
{
   uint8        # type id (DAO_ARRAY, DAO_LIST, ...);
   uint16       # scoping object reference number;
   uint16       # number of item types;
   uint16[]     # list of item types: type reference numbers;
}

# Value type:
def ValueType
{
	uint8       # type id (DAO_VALTYPE);
	uint16      # scoping object reference number;
	uint32      # value reference number for the value;
}

# Named parameter: name:type or name=type
def NameParamType
{
	uint8       # type id (DAO_PAR_NAMED or DAO_PAR_DEFAULT);
	uint16      # scoping object reference number;
	uint16      # identifier reference number;
	uint16      # type reference number;
}

# Type holder type:
def TypeHolderType
{
	uint8       # type id (DAO_THT);
	uint16      # scoping object reference number;
	uint16      # identifier reference number;
}

# Routine types:
def RoutineType
{
	uint8       # type id (DAO_ROUTINE);
	uint16      # scoping object reference number;
	uint16      # type reference number to the return type;
	uint16      # number of item types;
	uint16[]    # list of item types: type reference numbers;
}

# Interface type:
def InterfaceType
{
	uint8       # type id (DAO_CLASS);
	uint16      # scoping object reference number;
	uint16      # identifier reference number for the interface name;
}

# Class type:
def ClassType
{
	uint8       # type id (DAO_CLASS);
	uint16      # scoping object reference number;
	uint16      # identifier reference number for the class name;
}

# Class instance type:
def ClassInstanceType
{
	uint8       # type id (DAO_OBJECT);
	uint16      # scoping object reference number;
	uint16      # type reference number to the class type;
}

# Ctype type:
def CtypeType
{
	uint8       # type id (DAO_CTYPE);
	uint16      # scoping object reference number;
	uint16      # identifier reference number for the ctype name;
}

# Cdata type:
def CdataType
{
	uint8       # type id (DAO_CDATA);
	uint16      # scoping object reference number;
	uint16      # type reference number to the ctype type;
}

# Type type:
def TypeType
{
	uint8       # type id (DAO_TYPE);
	uint16      # scoping object reference number;
	uint16      # type reference number to the type;
}

# Future value type:
def FutureValueType 
{
	uint8       # type id (DAO_FUTURE);
	uint16      # scoping object reference number;
	uint16      # type reference number to the value type;
}
@[code(dao)]


Example,
@[code(dao)]
00 06           # uint16, number of types: 0x6;
02 00 00        # uint8 + uint16, float type in the default scope;
06 00 00        # uint8 + uint16, string type in the default scope;
07 00           # uint8 + uint8, enum type, non-flag type: enum<true,false>;
00 00           # uint16, scoping object reference number;
00 02           # uint16, number of items: 2;
00 01           # uint16, identifier reference number for "true";
00 02           # uint16, identifier reference number for "false";
08              # uint8, array type; array<float>;
00 00           # uint16, scoping object reference number;
00 01           # uint16, number of items: 1;
00 02           # uint16, type reference number for float;
@[code(dao)]



@[section]
Type Aliases
@[section]

@[code(dao)]
def TypeAlias
{
	uint16      # identifier reference number for the alias name;
	uint16      # type reference number;
}

def TypeAliases 
{
	uint16       # number of type aliases;
	TypeAlias[]  # list of type aliases;
}
@[code(dao)]

@[code(dao)]
00 01           # uint16, number of type aliases;
00 02           # uint16, identifier reference number for "short";
00 01           # uint16, type reference number of "int";
@[code(dao)]


@[section]
Values
@[section]

All values are stored with one byte of type ID followed by additional data.
Values are referenced by their 1-base indices in this section.
Value reference numbers are 32-bit unsigned integer.
Zero is reserved for a NULL value.


Value formats:
@[code(dao)]
# none:
def NoneValue
{
	uint8       # type ID (0x00, DAO_NONE);
}

# int:
def IntValue 
{   
   uint8      # type ID (0x01, DAO_INTEGER);
   int      # integer value;
}

# float:
def FloatValue
{   
   uint8        # type ID (0x02, DAO_FLOAT);
   double       # double value;
}

# double:
def DoubleValue
{   
   uint8        # type ID (0x03, DAO_DOUBLE);
   double       # double value;
}

# complex:
def ComplexValue
{   
   uint8        # type ID (0x04, DAO_COMPLEX);
   double       # double value, real part;
   double       # double value, imaginary part;
}

# long:
def LongValue
{   
   uint8        # type ID (0x05, DAO_LONG);
   int          # number of 256-base digits;
   uint8[]      # list of digits;
}

# string:
def StringValue
{   
   uint8        # type ID (0x06, DAO_STRING);
   uint8        # char type (0 for WCS, 1 for MBS);
   Variable number of bytes: list of characters (uint8 or uint32);
}

# enum:
def EnumValue
{
   uint8        # type ID (0x07, DAO_ENUM);
   uint16       # type reference number;
   uint32       # value;
}

# array:
def ArrayValue
{
   uint8        # type ID (0x08, DAO_ARRAY);
   uint8        # numeric type ID (for int, float, double or complex);
   int          # total number of elements;
   uint16       # number of dimensions;
   int[]        # list of dimension sizes (int);
   (int|float|double|complex)[]  # list of elements;
}

# list:
def ListValue
{
   uint8        # type ID (0x09, DAO_LIST);
   uint16       # type reference number;
   int          # number of items;
   uint32       # list of value reference numbers;
}

# map:
def MapValue
{
   uint8        # type ID (0x0A, DAO_MAP);
   uint8        # subtype (0x0 for map; 0x1 for hash);
   uint16       # type reference number;
   int          # number of items;
   uint32       # list of value reference numbers;
}

# tuple:
def TupleValue
{
   uint8        # type ID (0x0B, DAO_ARRAY);
   uint16       # type reference number;
   int          # number of items;
   uint32       # list of value reference numbers;
}

# Class instance:
# Complete instance:
def CompleteClassInstanceValue 
{
   uint8        # type ID (0x0C, DAO_OBJECT);
   uint8        # partial or complete (0x0 for complete and 0x1 for partial);
   uint16       # type reference number;

   uint16       # number of values;
   uint16[]     # list of value reference numbers;
}
# Partial instance is an instance embedded in another:
def PartialClassInstanceValue 
{
   uint8        # type ID (0x0C, DAO_OBJECT);
   uint8        # partial or complete (0x0 for complete and 0x1 for partial);
   uint16       # type reference number;

   uint16       # value offset;
   uint16       # value reference number for its host object;
}

# Routine:
def RoutineValue
{
   uint8        # type ID (0x11, DAO_ROUTINE);
   uint16       # scoping object reference number for the routine;
   uint16       # type reference number for the routine type;
}

# Class, ctype, interface and namespace:
def ClassCtypeInterfaceNamespaceValue
{
   uint8        # type ID (DAO_ROUTINE, DAO_CLASS, ...);
   uint16       # scoping object reference number;
}

# Type value:
def TypeValue
{
   uint8        # type ID (DAO_TYPE);
   uint16       # type reference number for the type;
}

# Imported value from loaded module:
def ExternalValue
{
	uint8       # 0xFF;
	uint32      # lookup index for values from loaded modules;
}


def Values
{
	uint32      # number of values;
	[]          # list of values;
}
@[code(dao)]


Example,
@[code(dao)]
00 00 00 23     # uint32, number of values: 0x23;
01              # uint8, value type id: integer;
00 15 23 12     # int, value: 0x152312;
02              # uint8, value type id: float;
00 00 00...     # double;
03              # uint8, value type id: double;
00 00 00...     # double;
04              # uint8, value type id: complex;
00 00 00...     # double;
00 00 00...     # double;
05              # uint8, value type id: long;
00 00 00 30     # int, length: 0x30;
...             # 0x30 bytes;
06              # uint8, value type id: string;
01              # uint8, string type: 0, WCS; 1, MBS;
00 00 00 30     # int, length: 0x30;
...             # 0x30 bytes;
07              # uint8, value type id: enum;
01 02           # uint16, type reference number for enum<true,false>;
00 00 00 02     # uint32, value: 0x2;
@[code(dao)]




@[section]
Global Constants
@[section]

Global constants are listed in the order of their declarations in the original
source file. Each constant is encoded in the following format,
@[code(dao)]
def Constant
{
	uint16      # identifier reference number for the constant name;
                # 0x0000 declares a constant without name;

	uint8       # permission (0: public; 1: protected: 2: private);
	uint32      # value reference number for the constant;
}

def GlobalConstants
{
	uint16      # number of global constants: 0x12;
	Constant[]  # list of constants;
}
@[code(dao)]


Example,
@[code(dao)]
00 12           # uint16, number of global constants: 0x12;
00 10           # uint16, identifier reference number for the constant name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the constant;
00 15           # uint16, identifier reference number for the constant name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the constant;
...
@[code(dao)]


@[section]
Global Variables
@[section]

Global variables are listed in the order of their declarations in the original
source file. Each variable is encoded in the following format,
@[code(dao)]
def Variable
{
	uint16      # identifier reference number for the variable name;
	            # 0x0000 will declare a variable without name;

	uint8       # permission (0: public; 1: protected: 2: private);
	uint16      # type reference number for the variable;
	            # 0x0000 can be used for variables without explicit types;

	uint32      # value reference number for the initial or default value;
	            # 0x00000000 can be used for variables without such value;
}

def GlobalVariables
{
	uint16      # number of global variables: 0x12;
	Variable[]  # list of variables;
}
@[code(dao)]


Example,
@[code(dao)]
00 23           # uint16, number of global variables: 0x23;
00 11           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 03           # uint16, type reference number for the variable;
00 00 00 02     # uint32, value reference number for the variable;
00 14           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 03           # uint16, type reference number for the variable;
00 00 00 05     # uint32, value reference number for the variable;
...
@[code(dao)]




@[section]
Interfaces
@[section]


Each interface is declared with the following fields:
@[code(dao)]
def Interface 
{
	uint16      # scoping object reference number to the interface;
	uint16      # number of parent interfaces;
	uint16      # list of scoping object reference numbers to parents;
	uint16      # number of abstract methods;
	uint32      # list of value reference numbers to the methods;
}

def Interfaces 
{
	uint16       # number of interfaces;
	Interface[]  # list of interfaces;
}
@[code(dao)]


Example,
@[code(dao)]
00 01           # uint16: number of interfaces;
00 09           # uint16: scoping object reference number to the interface;
00 01           # uint16: number of parent interfaces;
00 08           # uint16: scoping object reference number to the parent interface;
00 02           # uint16: number of abstract methods;
00 00 00 09     # uint32: value reference number to the abstract method;
00 00 00 11     # uint32: value reference number to the abstract method;
@[code(dao)]


@[section]
Classes
@[section]


Each class is declared in the following format:
@[code(dao)]
def Class 
{
	uint16      # scoping object reference number to the class;
	uint16      # number of parent classs;
	uint16[]    # list of scoping object reference numbers to the parents;
	uint16      # number of constants (including methods);
	Constant[]  # list of constants in the same foramt as global constants;
	uint16      # number of static varaibles;
	Variable[]  # list of variables in the same foramt as global variables;
	uint16      # number of instance varaibles;
	Variable[]  # list of variables in the same foramt as global variables;
}

def Classes 
{
	uint16      # number of classes;
	Class[]     # list of classes;
}
@[code(dao)]


Example,
@[code(dao)]
00 01           # uint16, number of classes: 0x1;
00 09           # uint16: scoping object reference number to the class;
00 01           # uint16: number of parent classs;
00 08           # uint16: scoping object reference number to the parent class;
00 02           # uint16: number of constants;
00 10           # uint16, identifier reference number for the constant name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the constant;
00 15           # uint16, identifier reference number for the constant name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the constant;
00 02           # uint16: number of static variables;
00 10           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the variable;
00 15           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the variable;
00 02           # uint16: number of instance variables;
00 10           # uint16, identifier reference number for the variable name;
00              # uint8, public;
00 00 00 01     # uint32, value reference number for the variable;
00 15           # uint16, identifier reference number for the variable name;
01              # uint8, protected;
00 00 00 03     # uint32, value reference number for the variable;
@[code(dao)]




@[section]
Routines
@[section]


@[code(dao)]
def Instruction 
{
	uint16      # opcode;
	uint16      # oprand a;
	uint16      # oprand b;
	uint16      # oprand c;
	uint16      # lexical level;
	uint16      # line;
}

def Routine 
{
	uint16      # scoping object reference number to the routine;
	uint16      # scoping object reference number to the host of the routine;
	uint16      # identifier reference number to the routine name;
	uint16      # type reference number to the routine type;
	uint16      # line of definition;
	uint16      # number of local constants;
	uint32[]    # list of value reference numbers for the constants;
	uint16      # number of local variables;
	uint16[]    # list of type reference numbers for the local variable;
	uint16      # number of instructions;
	Instruction[] # list of instructions;
}

def Routines
{
	uint16      # number of routines;
	Routine[]   # list of routines;
}
@[code(dao)]


@[text]
