load help;

@[name]
daovm.architecture
@[name]

@[title]
The architecture of the Dao Virtual Machine
@[title]




@[name]
daovm.architecture.vmspace
@[name]

@[title]
Virtual Machine Space
@[title]


@[name]
daovm.architecture.namespace
@[name]

@[title]
Namespace
@[title]


@[name]
daovm.architecture.class
@[name]

@[title]
Class
@[title]


@[name]
daovm.architecture.routine
@[name]

@[title]
Routine
@[title]


@[name]
daovm.architecture.process
@[name]

@[title]
Virutal Machine Process
@[title]


@[name]
daovm.architecture.instruction
@[name]

@[title]
Virtual Machine Instructions
@[title]





@[name]
daovm.architecture.bytecode
@[name]

@[title]
Binary Bytecode Format
@[title]

@[text]


This document contains specifications of the bytecode format for Dao virtual machine.
In this bytecode format, integers are always stored in big endian.


In the following specifications or examples, each byte is represented by
two hexadecimal digits, unless it is quoted by quotation marks.


Data type used in the specification:
@[code(dao)]
type int8       # one byte signed integer;
type uint8      # one byte unsigned integer;
type uint16     # two byte unsigned integer;
type uint32     # four byte unsigned integer;
type int        # four or eight byte integer;
type double     # IEEE 754 double;

struct short_string
{
	uint16      # string length;
	int8[]      # character array;
}
@[code(dao)]


A Dao binary bytecode file will contain the following sections:
@[list]
==@[green]Header@[green]: basic information for the format;
==@[green]Source@[green]: path and file name of the source;
==@[green]Identifiers@[green]: identifiers used in the file;
==@[green]Modules@[green]: modules need to be loaded;
==@[green]Declarations@[green]: forward declaration of routines and classes etc.;
==@[green]Types@[green]: declaration of types;
==@[green]Values@[green]: all the values used in the file;
==@[green]Global Constants@[green]: global constants;
==@[green]Global Variables@[green]: global variables;
==@[green]Global Types@[green]: global types;
==@[green]Interfaces@[green]: interface definitions;
==@[green]Classes@[green]: class definitions;
==@[green]Routines@[green]: routine definitions;
@[list]


@[section]
Header
@[section]

Dao binary bytecode file begins with a header of 16 bytes consisting 
of the following parts:
@[code(dao)]
struct Header 
{
	uint8       # ESC, 0x1B;
	uint8       # 0x44, namely 'D';
	uint8       # 0x61, namely 'a';
	uint8       # 0x6F, namely 'o';
	uint8       # major version number, 0x1;
	uint8       # minor version number, 0x2;
	uint8       # Carriage Return (CR), 0x0D;
	uint8       # Line Feed (LF), 0x0A;
	uint8       # format version, 0x0 for the official one;
	uint8       # size of integer type, default 0x4;
	uint8[6]    # six reserved bytes;
}
@[code(dao)]
Example,
@[code(dao)]
1B 44 61 6F 01 02 0D 0A    # 8 bytes, signature for Dao 1.2;
00                         # uint8, format version: zero for official;
04                         # uint8, size of int: default 4;
00 00 00 00 00 00          # 6 byte, reserved;
@[code(dao)]
Regardless the size of integer, the bytecode should be loadable on both
32-bit and 64-bit Dao Virtual Machines, as long as the integers used
in the bytecode file do not overflow.



@[section]
Source
@[section]

The source file name (possibly including the path) is stored immediately after
the header as a @[green]short_string@[green]:
@[code(dao)]
struct Source
{
	short_string  # source name;
}
@[code(dao)]
Example,
@[code(dao)]
00 09            # uint16, source name length in bytes;
"test.dao"       # variable number of bytes;
@[code(dao)]




@[section]
Identifiers
@[section]

Identifiers are referenced by 1-base indices in this section,
such reference numbers are encoded in 16-bit unsigned integers.
Zero 0x0000 is used to indicate non-existing identifier,
which can be used to declare constants or variables which
occupy slots in the constant or variable arrays without names.

@[code(dao)]
struct Identifiers
{
	uint32          # number of identifiers;
	short_string[]  # list of identifier strings;
}
@[code(dao)]


@[section]
Modules
@[section]

This section lists the modules that are needed for the current codes.
They will be loaded in order to properly decode the rest of the bytecode file.
@[code(dao)]
struct Modules
{
	uint32          # number of modules;
	struct {
		uint32      # identifier reference number for the module file name;
		uint32      # identifier reference number for the module alias;
	}[]
}
@[code(dao)]




@[section]
Declarations
@[section]


Forward declarations of classes, interfaces, routines, ctype and namespace etc.
Each declaration is referenced by an unsigned 16-bit integer,
with 0x0000 reserved for the current namespace.
Scope objects listed in this section should be referenced by the 1-base index in this section.


Each declaration entry has the following fields:
@[code(dao)]
struct Declaration
{
	uint8       # object type (internal type ID);
	uint8       # object subtype;
	uint8       # declaration type (0x0 for CREATE; 0x1 for SEARCH; 0x2 for LOADAS);
	uint32      # identifier reference number for the declaration name;
	            # declaration reference number for the namespace (for LOADAS);
	uint32      # declaration reference number for the host object;
	uint32      # identifier reference number for the field name in the host;
}
struct Declarations 
{
	uint32         # number of declarations;
	Declaration[]  # list of declarations;
}
@[code(dao)]



@[section]
Types
@[section]


The type section will declare a list of types
which can be referenced by their 1-based 16-bit integer indices in this section.
Zero is used to indicate a unspecified type.
Each type is declared with one byte for its internal type ID,
and two bytes of identifier reference number for its type name, 
followed by addition information.
A zero identifier reference number indicates the type has default
name that will be constructed from the type information.


Type declaration formats:
@[code(dao)]
# Core types: none, integer, float, ..., string:
struct CoreType 
{
	uint8       # type id (DAO_NONE, DAO_INTEGER, ...);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
}

# Enum type:
struct EnumType 
{
	uint8       # type id (DAO_ENUM);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint8       # sub type, 0 for normal enums, 1 for flags;
	uint16      # number of symbols;
	struct {
		uint32  # identifier reference number to the symbol;
		uint32  # values associated with the symbol;
	}[]         # list of symbols;
}

# Array, List, Map, Tuple, Type and Future Value type:
struct ContainerType
{
	uint8       # type id (DAO_ARRAY, DAO_LIST, ...);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint16      # number of item types;
	uint32[]    # list of item types: type reference numbers;
}

# Variant type
struct VariantType
{
	uint8       # type id (DAO_ARRAY, DAO_LIST, ...);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # type reference number to the type holder, if it has;
	uint16      # number of item types;
	uint32[]    # list of item types: type reference numbers;
}

# Value type:
struct ValueType
{
	uint8       # type id (DAO_VALTYPE);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # value reference number for the value;
}

# Named parameter: name:type or name=type
struct NameParamType
{
	uint8       # type id (DAO_PAR_NAMED or DAO_PAR_DEFAULT);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # identifier reference number to the parameter name;
	uint32      # type reference number;
}

# Type holder type:
struct TypeHolderType
{
	uint8       # type id (DAO_THT);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
}

# Codeblock type:
struct CodeBlockType
{
	uint8       # type id (DAO_CODEBLOCK);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # type reference number to the return type;
	uint16      # number of item types;
	uint32[]    # list of item types: type reference numbers;
}

# Routine types:
struct RoutineType
{
	uint8       # type id (DAO_ROUTINE);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number (for overloaded routine type);
	uint32      # type reference number to the return type;
	uint32      # type reference number for the codeblock type;
	uint16      # number of item types;
	uint32[]    # list of item types: type reference numbers;
}

# Interface type:
struct InterfaceType
{
	uint8       # type id (DAO_INTERFACE);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number for the interface;
}

# Class type:
struct ClassType
{
	uint8       # type id (DAO_CLASS);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number for the class;
}

# Class instance type:
struct ClassInstanceType
{
	uint8       # type id (DAO_OBJECT);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number for the class;
}

# Ctype type:
struct CtypeType
{
	uint8       # type id (DAO_CTYPE);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number for the ctype;
}

# Cdata type:
struct CdataType
{
	uint8       # type id (DAO_CDATA);
	uint8       # type attributes;
	uint32      # identifier reference number to the type name;
	uint32      # declaration reference number for the ctype;
}

@[code(dao)]





@[section]
Values
@[section]

All values are stored with one byte of type ID followed by additional data.
Values are referenced by their 1-base indices in this section.
Value reference numbers are 32-bit unsigned integer.
Zero is reserved for a NULL value.


Value formats:
@[code(dao)]
# none:
struct NoneValue
{
	uint8       # type ID (0x00, DAO_NONE);
}

# int:
struct IntValue 
{   
	uint8       # type ID (0x01, DAO_INTEGER);
	int         # integer value;
}

# float:
struct FloatValue
{   
	uint8       # type ID (0x02, DAO_FLOAT);
	double      # double value;
}

# double:
struct DoubleValue
{   
	uint8       # type ID (0x03, DAO_DOUBLE);
	double      # double value;
}

# complex:
struct ComplexValue
{   
	uint8       # type ID (0x04, DAO_COMPLEX);
	double      # double value, real part;
	double      # double value, imaginary part;
}

# long:
struct LongValue
{   
	uint8       # type ID (0x05, DAO_LONG);
	uint8       # sign, 0 for positive, 1 for negative;
	int         # number of 256-base digits;
	uint8[]     # list of digits;
}

# string:
struct StringValue
{   
	uint8       # type ID (0x06, DAO_STRING);
	uint8       # high 4 bits, char type (0 for WCS, 1 for MBS);
	            # low 4 bits, char size in bytes (1 for MBS; 1,2,4 for WCS);
	int         # number of characters;    
	(int8|uint32)[]  # list of characters;
}

# enum:
struct EnumValue
{
	uint8       # type ID (0x07, DAO_ENUM);
	uint32      # type reference number;
	uint32      # value;
}

# array:
struct ArrayValue
{
	uint8       # type ID (0x08, DAO_ARRAY);
	uint8       # numeric type ID (for int, float, double or complex);
	int         # total number of elements;
	uint16      # number of dimensions;
	int[]       # list of dimension sizes (int);
	(int|float|double|complex)[]  # list of elements;
}

# list:
struct ListValue
{
	uint8       # type ID (0x09, DAO_LIST);
	uint32      # type reference number;
	int         # number of items;
	uint32[]    # list of value reference numbers;
}

# map:
struct MapValue
{
	uint8       # type ID (0x0A, DAO_MAP);
	uint32      # hashing seed;
	uint32      # type reference number;
	int         # number of items;
	uint32[]    # list of value reference numbers;
}

# tuple:
struct TupleValue
{
	uint8       # type ID (0x0B, DAO_ARRAY);
	uint32      # type reference number;
	uint32      # number of items;
	uint32[]    # list of value reference numbers;
}

# Class instance:
# Complete instance:
struct CompleteClassInstanceValue 
{
	uint8       # type ID (0x0C, DAO_OBJECT);
	uint8       # flag (0x0 for complete);
	uint32      # declaration reference number for the class;

	uint16      # number of values;
	uint32[]    # list of value reference numbers;
}
# Partial instance is an instance embedded in another:
struct PartialClassInstanceValue 
{
	uint8       # type ID (0x0C, DAO_OBJECT);
	uint8       # flag (0x1 for partial);
	uint32      # declaration reference number for the class;

	uint16      # value offset;
	uint32      # value reference number for its host object;
}
# The default instance for the class:
struct DefaultClassInstanceValue 
{
	uint8       # type ID (0x0C, DAO_OBJECT);
	uint8       # flag (0x2 for default);
	uint32      # declaration reference number for the class;
}

# Routine:
struct RoutineValue
{
	uint8       # type ID (0x11, DAO_ROUTINE);
	uint32      # declaration reference number for the routine;
	uint32      # type reference number for the routine type;
	uint32      # type reference number for the host type;
	uint8       # routine attributes;
}

# Class, ctype, interface and namespace:
struct ClassCtypeInterfaceNamespaceValue
{
	uint8       # type ID (DAO_ROUTINE, DAO_CLASS, ...);
	uint32      # declaration reference number;
}

# Type value:
struct TypeValue
{
	uint8       # type ID (DAO_TYPE);
	uint32      # type reference number for the type;
}


# Named value:
struct NamedValue
{
	uint8       # type ID (DAO_PAR_NAME);
	uint32      # identifier reference number for the name;
	uint32      # type reference number for the type;
	uint32      # value reference number for the value;
}

# Imported value from loaded module:
struct ExternalValue
{
	uint8       # 0xFF;
	uint32      # lookup index for values from loaded modules;
}


struct Values
{
	uint32      # number of values;
	[]          # list of values;
}
@[code(dao)]




@[section]
Global Constants
@[section]

Global constants are listed in the order of their declarations in the original
source file. Each constant is encoded in the following format,
@[code(dao)]
struct Constant
{
	uint32      # identifier reference number for the constant name;
                # 0x0000 declares a constant without name;

	uint16      # lookup index;
	uint8       # permission (0: public; 1: protected: 2: private);
	uint32      # value reference number for the constant;
}

struct GlobalConstants
{
	uint32      # number of global constants;
	Constant[]  # list of constants;
}
@[code(dao)]




@[section]
Global Variables
@[section]

Global variables are listed in the order of their declarations in the original
source file. Each variable is encoded in the following format,
@[code(dao)]
struct Variable
{
	uint32      # identifier reference number for the variable name;
	            # 0x0000 will declare a variable without name;

	uint16      # lookup index;
	uint8       # permission (0: public; 1: protected: 2: private);
	uint32      # type reference number for the variable;
	            # 0x0000 can be used for variables without explicit types;

	uint32      # value reference number for the initial or default value;
	            # 0x00000000 can be used for variables without such value;
}

struct GlobalVariables
{
	uint32      # number of global variables;
	Variable[]  # list of variables;
}
@[code(dao)]






@[section]
Global Types
@[section]

Each global type declaration is encoded in the following format,
@[code(dao)]
struct Type
{
	uint32      # identifier reference number for the type name;
	uint32      # type reference number for the type;
}

struct GlobalTypes
{
	uint32      # number of global types;
	Type[]      # list of types;
}
@[code(dao)]





@[section]
Interfaces
@[section]


Each interface is declared with the following fields:
@[code(dao)]
struct Interface 
{
	uint32      # declaration reference number to the interface;
	uint16      # number of parent interfaces;
	uint32[]    # list of declaration reference numbers to parents;
	uint16      # number of abstract methods;
	uint32[]    # list of value reference numbers to the methods;
}

struct Interfaces 
{
	uint32       # number of interfaces;
	Interface[]  # list of interfaces;
}
@[code(dao)]




@[section]
Classes
@[section]


Each class is declared in the following format:
@[code(dao)]
struct Class 
{
	uint32      # declaration reference number to the class;
	uint32      # declaration reference number to the default constructor;
	uint16      # class attributes;
	uint16      # number of parent classs;
	uint32[]    # list of declaration reference numbers to the parents;
	uint16      # number of constants (including methods);
	Constant[]  # list of constants in the same format as global constants;
	uint16      # number of static varaibles;
	Variable[]  # list of variables in the same format as global variables;
	uint16      # number of instance varaibles;
	Variable[]  # list of variables in the same format as global variables;
	uint16      # number of types in the class scope;
	Type[]      # list of types;
}

struct Classes 
{
	uint32      # number of classes;
	Class[]     # list of classes;
}
@[code(dao)]






@[section]
Routines
@[section]


@[code(dao)]
struct Instruction 
{
	uint16      # opcode;
	uint16      # oprand a;
	uint16      # oprand b;
	uint16      # oprand c;
	uint16      # lexical level;
	uint16      # line;
}

struct Routine 
{
	uint32         # declaration reference number to the routine;
	uint32         # identifier reference number to the routine name;
	uint32         # type reference number for the routine type;
	uint32         # type reference number for the host type;
	uint32         # declaration reference number to the up routine;
	uint16         # attributes;
	uint16         # line of definition;
	uint16         # number of local constants;
	uint32[]       # list of value reference numbers for the constants;
	uint16         # number of local variables;
	uint16         # number of local variables with explicit types;
	struct {       # list of variable indices with type reference numbers;
		uint16     # variable index;
		uint32     # type reference number for the variable type;
	}
	uint16         # number of instructions;
	Instruction[]  # list of instructions;
}

struct Routines
{
	uint32      # number of routines;
	Routine[]   # list of routines;
}
@[code(dao)]


@[text]
