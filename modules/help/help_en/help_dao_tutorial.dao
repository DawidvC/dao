load help;

@[name]
dao.tutorial
@[name]

@[title]
Dao Programming Tutorials
@[title]

@[name]
dao.tutorial.basics
@[name]

@[title]
Dao Programming Basics
@[title]

@[text]

This tutorial will cover some of the basics of Dao programming.
We will start with the traditional @[green]str world@[green] example.


@[subsection]
Hello World!
@[subsection]

To simply write "Hello world!" to the screen, one can use,
@[code]
io.write( 'Hello world!' )
@[code]
In this simple example, the built-in @[green]io@[green] module is used
to access the IO functionalities of the module.
@[green]write()@[green] is a method provided by the @[green]io@[green] module
to write outputs on to the standard output (the screen in this case).
In Dao, string can be quoted with a pair of single quotation marks
or with a pair of double quotation marks.


@[subsection]
Running Scripts
@[subsection]

There are three ways to run codes in Dao.
The most typical way is to create a script file (e.g. @[cyan]str_world.dao@[cyan]),
and put the codes into this file, and then run @[green]dao@[green] using this file
as argument,
@[code]
$$ dao str_world.dao
@[code]

But if you just want to run the codes once, you can simple run them from command line using,
@[code]
$$ dao -e "io.write( 'Hello world!' )"
@[code]

For learning Dao, it may be the best to run codes in interactive mode.
Invoking @[green]dao@[green] without any argument will start an interactive shell,
@[code]
$$ dao

  Dao Virtual Machine 1.2
  Built date: Jun 20 2012
  Changeset ID: FOS.a019d384dd7c

  Copyright(C) 2006-2012, Fu Limin
  Dao is released under the terms of the Simplified BSD License
  Dao Language website: http://www.daovm.net

(dao) 
@[code]
If you have the Dao @[green]help@[green] properly installed,
starting @[green]dao@[green] in interactive mode will automatically load
the help files and print out the following information,
@[code]
  Module Help is loaded.
  Now you may run "help()" to list all the available help entries;
  or run "help('help')" for detailed information about the help system.
@[code] 
If you are reading this tutorial from a webpage, and want to access it from
the interactive command line, you can simple run,
@[code]
(dao) help( 'dao.tutorial.basics' )
@[code]



@[subsection]
Commenting Codes
@[subsection]

It is always a good idea to comment your codes.
Dao supports both single line comments and multiple line comments.
A single comment starts at a @[green]#@[green] 
(not followed by a left curly bracket @[green]{@[green]),
and ends at the end of the current line.
And a multiple line comment (or just part of a single line)
opens by @[green]#{@[green] and closes by @[green]#}@[green].
For example,
@[code]
# This is a simple demo:
io.write( "Hello World!" #{ comment inside codes #} );
#{
Here are multi-lines comments.
Here are multi-lines comments.
#}
@[code]

@[text]




################################################################################
################################################################################
######## Types
################################################################################
################################################################################

                                                                                            
@[name]
dao.tutorial.types
@[name]

@[title]
Dao Basic Types
@[title]

@[text]



@[subsection]
Numbers
@[subsection]
Dao has native supports for the following types of numbers:
@[green]int@[green], @[green]float@[green], @[green]double@[green],
@[green]complex@[green] and @[green]long@[green].


@[green]int@[green] and @[green]float@[green] numbers can be expressed
in the same ways as most other languages. But a @[green]double@[green] number,
need a @[green]D@[green] suffix to @[green]int@[green] or @[green]float@[green] number
to be parsed as a double precision floating point number.


For numbers written in scientific format,
lower case @[green]e@[green] is used for @[green]float@[green];
while upper case @[green]E@[green] is used for @[green]double@[green].


A @[green]complex@[green] number can be expressed as an @[green]int@[green]
or @[green]float@[green] number with a @[green]$@[green] suffix.


@[green]long@[green] type represents arbitrary precision integers. They
can be expressed as an @[green]int@[green] number with
a @[green]L@[green] or a @[green]Lx@[green] suffix,
where @[green]x@[green] is an integer between 2 and 16 (inclusive),
representing the base of the number (used for parsing and printing only).


Examples,
@[code]
I1 = 123
I2 = 0xabc

F1 = 456.7
F2 = 123e4

D1 = 123D
D2 = 456.7D
D3 = 123E4

C1 = 123$
C2 = 456.6$

L1 = 123456789L
L2 = 10001001110L2
L3 = 0x123abc456L16
@[code]


These types support most of the common operators that are meaningful for them.
For example, all the basic arithmetic operators such as:
@[green]+@[green] (addition, unary plus), @[green]-@[green] (subtraction, unary minus),
@[green]*@[green] (multiplication), @[green]/@[green] (division),
@[green]%@[green] (modulo) and @[green]**@[green] (power)
are supported.
@[code]
I1 = 123 + 456
I2 = 789 % 123
F1 = 123.5 ** 3
D1 = 789.5D / 123
L1 = 123456789L ** 123L
@[code]

Please see @[node]dao.type.int@[node], @[node]dao.type.float@[node],
@[node]dao.type.double@[node], @[node]dao.type.complex@[node] and @[node]dao.type.long@[node]
for more information.




@[subsection]
Strings
@[subsection]

In Dao, a string can be expressed as a sequence of characters enclosed by
a pair of single qutotation marks or a pair of double quotation marks.
The characters placed between the quotation marks must be formated according
some rules (such as escaping quotation marks and other special characters
and using numeric encodings of characters etc.).
Please see @[node]dao.type.string@[node] for more information.
@[code]
mbs = 'str'
wcs = "道语言"
mbs2 = 'It\'s green'
wcs2 = "\u9053\u8bed\u8a00" # the same as wcs;
@[code]


To use strings as it is written without special treatment of the characters,
they can be expressed as @[green]verbatim@[green] string, which are quoted with
a pair of identical compound marks in the forms of @[green]@[]@[green]
and @[green]@@[]@[green].
Any number of letters, digits, underscores, blank spaces, dots, 
colons, dashes and assignment marks can be placed in between the squared brackets
to make sure the marks will not appear inside the string.
The difference between using @[green]@[]@[green] and @[green]@@[]@[green]
is the same as the difference between using single quotation marks and double quotation marks.
Please see @[node]dao.type.string@[node] for more information.
@[code]
# C++ codes in MBS:
cpp =
@[cpp x]
class AA
{
	int index;
};
struct BB{};
@[cpp x]


# Lua codes in WCS:
lua =
@@[lua]
local a = 1;
function Test()
	io.write( 'Hello' )
end
@@[lua]
@[code]

The content of a string can be accessed or altered using sub-indexing or slicing:
@[code]
str = 'ABCDEFGHIJK';

io.writeln( str[1] )    # the second character;
io.writeln( str[:4] )   # the substring from the start to the 4th character;
io.writeln(  str[6:] )  # the substring from the 6th character to the end;
io.writeln(  str[3:8] ) # the substring from the 3rd to the 8th character;

# Set single character:
str[1] = 'X';
str[1] = 'X'[0];

# Set a substring:
str[2:5] = '1234'   # str = 'AB1234GHIJK'
str[2:5] = '123456' # str = 'AB123456GHIJK'
str[2:5] = '12'     # str = 'AB12GHIJK'

# Using negative index:
io.writeln( str[-1] )    # the last character;
io.writeln( str[-2] )    # the second last character;
io.writeln( str[-2:] )   # the last two characters;
@[code]

String can be concaternated using @[green]+@[green] or @[green]+=@[green],
@[code]
str = 'ABCDEFGHIJK';

str2 = str + '123'  # str2 = ABCDEFGHIJK123

# Append a string:
str += '123' # str = ABCDEFGHIJK123

# Append a character:
str += 88    # str = ABCDEFGHIJK123X
@[code]





@[subsection]
Arrays
@[subsection]

Dao has built-in support for multi-dimensional numeric arrays.
Such arrays can be defined by using the squared brackets
@[green][]@[green] or @[green]array{}@[green].
Using such constructs, one can either enumerate all the elements
as a vector/matrix, or specify an arithmetic progression with
a start value, a step value and the number of steps.
If the step value is omitted, it will be assumed to be one.

@[code]
vec1 = [1, 2, 3]  # array<int> vector, or 1x3 matrix;
vec2 = [1.0; 2; 3]  # array<float> 3x1 matrix, or transposed vector;
mat1 = [1D, 2; 3, 4]  # array<double> 2x2 matrix;
mat2 = [ [1, 2], [3, 4] ]  # 2x2 matrix
mat3 = [ 5 ~ [1, 2, 3] ]   # 5x3 matrix;
mat4 = array{ 1, 2; 3, 4 }  # 2x2 matrix
@[code]

Like string, array support sub-indexing, slicing and negative indices:
@[code]
mat = [ 1, 2, 3; 4, 5, 6; 7, 8, 9 ];  # 3x3 matrix;

rowvec = mat[1,:]  # the second row;
colvec = mat[:,1]  # the second column;

submat1 = mat[:1,:]  # the first two rows;
submat2 = mat[:,1:]  # the last two columns;
submat3 = mat[:1,1:] # intersection between the first two rows and the last two columns;

mat[0,:]  = [11, 22, 33]  # set the first row to [11, 22, 33];
mat[:,1] += [11, 22, 33]  # add [11, 22, 33] to the second column;
mat[:,1] += 100           # add 100 to the second column;

mat[:1,1:] += [10, 20; 30, 40]  # add [10, 20; 30, 40] to sub-matrix of mat;
@[code]

Please see @[node]dao.type.array@[node] for more information.




@[subsection]
Lists
@[subsection]

List can be created in similar ways as array, by enumerating elements or specifying
an arithmetic progression, but using @[green]{}@[green] or @[green]list{}@[green]
instead of @[green][]@[green] or @[green]array{}@[green].

@[code]
list1 = { 1, 2, 3 }    # list<int>
list2 = { 1.0, 2, 3 }  # list<float>
list3 = { 5 ~ 1 ~ 2 }  # list<int>

list4 = { 'abc', 'def' }  # list<string>
list5 = { 123, 'abc' }    # list<any>

list6 = list{ 3 ~ 'a' }    # { 'a', 'a', 'a' }
list7 = { 3 ~ 'a' ~ 'b' }  # { 'a', 'ab', 'abb' }
@[code]

List also supports sub-indexing, slicing and negative indices:
@[code]
alist = { 0, 1, 2, 3, 4, 5 }

item = alist[1]
item = alist[-2]

sublist = alist[2:4]

alist[3]  = 10
alist[4] += 10
@[code]





@[subsection]
Maps and hash maps
@[subsection]

A map or hash map organize a set of key/value pairs into a structure
for efficient lookup. The keys in a map are ordered, while the keys
in a hash map is unordered.
A map can be created using @[green]{key=>value...}@[green] or
@[green]map{key=>value...}@[green]. Replacing the @[green]=>@[green]
will create hash maps.
Map and hash map can be used in identical ways.
@[code]
amap = { 'abc' => 123, 'def' => 456 }
ahash = { 'abc' : 123, 'def' : 456 }

amap = map{ 'abc' => 123, 'def' => 456 }
ahash = map{ 'abc' : 123, 'def' : 456 }
@[code]

Sub-scripting and slicing are also supported for map to access value(s)
through key(s).
@[code]
amap = { 'abc' => 123, 'def' => 456, 'ghi' => 789 }

value  = amap[ 'abc' ];
submap = amap[ 'abc' : 'def' ];
@[code]






@[subsection]
Tuples
@[subsection]

Tuple is a very handy type, which can be used to hold a fixed number of items,
with type information recorded for each of them.
In a tuple, each item can have a name, which can be used to access
the item as field.
They can be created in similar ways as creating lists and maps,
but use @[green]()@[green] instead.
@[code]
tup1 = ( 123, 'abc' )               # tuple with unnamed items;
tup2 = ( index => 123, 'abc' )      # the first item is named as "index";
tup3 = tuple{ 123, name => 'abc' }  # the second item is named as "name";
@[code]

Each item of a tuple can be accessed using its index or field (item name).
New tuples can be created from other tuples by slicing.
@[code]
tup = ( index => 123, 'abc', [1,2,3] )

id = tup[0]
id = tup.index
tup.index = 456

tup2 = tup[:1]  # ( index => 123, 'abc' )
@[code]



@[text]



################################################################################
################################################################################
######## Controls
################################################################################
################################################################################

@[name]
dao.tutorial.controls
@[name]

@[title]
Dao Constrol Structures
@[title]

@[text]


@[subsection]
If-Else
@[subsection]

If a condition is true, execute a block of codes:
@[code]
if( expr1 ){
   block1;
}elif( expr2 ){
   block2;
}else{
   block3;
}
@[code]

If @[cyan]expr1@[cyan] is true, @[cyan]block1@[cyan] is executed;
otherwise, if @[cyan]expr2@[cyan] is true, @[cyan]block2@[cyan] is executed;
otherwise, @[cyan]block3@[cyan] is executed; zero or more @[green]elseif@[green]
and zero or one @[green]else@[green] statement can be used.

@[code]
if( 2 > 1 ) io.writeln("2 is larger than 1.");
@[code]






@[subsection]
For
@[subsection]

Dao supports different styles of for-looping, the most useful one is probably the following,
@[code]
for( var = init_value : step_value : max_value ){
   block;
}
@[code]
The looping will be started with @[cyan]var = init_value@[cyan],
then after each cycle, @[cyan]var@[cyan] is increased by @[cyan]step_value@[cyan],
the looping will stop when the value of @[cyan]var@[cyan] exceed the @[cyan]max_value@[cyan].
The @[cyan]step_value@[cyan] can be omit, in this case, value 1 is taken as the step.
Please note, the initial, step and maximum values are always evaluated before the
looping.


C/C++ style @[green]for@[green] looping is supported by Dao:
@[code]
for( init; condition; step ){
   block;
}
@[code]

The execution sequence of @[green]for@[green] statement is the following:

@[list]
== execute initial expression @[cyan]init@[cyan], and goto 3;
== execute @[cyan]step@[cyan];
== evaluate the condition expression @[cyan]condition@[cyan];
== check the value of @[cyan]condition@[cyan]: if true, goto 5; otherwise, goto 6;
== execute @[cyan]block@[cyan], and goto 2;
== stop looping; and start to execute the statements after the loop body.
@[list]

Usually, the C/C++ style @[green]for@[green] loop is equivalent to,
@[code]
init;
while( condition ){
   block;
   step;
}
@[code]

Dao also supports Python style @[cyan]for-in-do@[cyan] loop,
@[code]
for( item in list ){
   block;
}
@[code]

Multiple @[cyan]in@[cyan] can appear in one loop, and the items of the same
indices from multiple lists are taken in each cycle. These lists should
contain the same number of items, otherwise an exception will be arose,
as shown in the following example.
@[code]
for( item1 in list1; item2 in list2; ... ){
   block;
}
@[code]

@[cyan]for-in@[cyan] can also be used for maps,
@[code]
for( item in a_map ){
   block;
}
@[code]

Examples,
@[code(dao)]
for( i:=0; i<3; i++ ){
   io.writeln( i );
}

hash = { "b" => 11, "a" => 22, "e" => 33, "c" => 44 };
for( a in hash.key(); b in hash.value(); c in {1 : 1 : hash.size()-1 } ){
   #if a == "a" break
   io.writeln( a, b, c );
}
@[code(dao)]
This example raises an exception, because the last list @[cyan]c@[cyan] contains
one less element.


Note: if a single string is used in the condition expression in @[green]if,while,for@[green] statements,
it returns true, if the string has length larger than zero, otherwise, returns false.





@[subsection]
While
@[subsection]

When a condition is true, @[green]repeatedly@[green] execute a block of codes:
@[code]
while( expr ){
   block;
}
@[code]

If @[cyan]expr@[cyan] is true, @[cyan]block@[cyan] is executed and repeated until @[cyan]expr@[cyan] becomes false,
namely, while @[cyan]expr@[cyan] is true, execute @[cyan]block@[cyan].

@[code]
i = 0;
while( i < 5 ){
   io.writeln( i );
   i ++;
}
@[code]





@[subsection]
Do-While
@[subsection]

@[code]
do{
	block;
} while ( condition )
@[code]
Execute @[cyan]block@[cyan], and then repeat executing it when the @[cyan]condition@[cyan] is true.





@[subsection]
Switch-Case
@[subsection]

Switch-case control provides a convenient way to branch the code and choose a block of code to
execute based on the value of a object.
@[code]
switch( value ){
   case C_1 : block_1
   case C_2 : block_2
   case C_3 : block_3
   ...
   default: block0
}
@[code]
If the @[cyan]value@[cyan] equals to @[cyan]C_i@[cyan], @[cyan]block_i@[cyan] will be executed. Here @[cyan]C_i@[cyan] must be a constant,
but they can be of different types, that means, you can mix numbers and strings as case values.
Unlike in C/C++, no @[green]break@[green] statement is required to get out of the @[green]switch@[green].


If you want to execute the same block of codes for different case values, you just need to
organize them together in the following way:
@[code]
switch( value ){
   case C1, C2, C3 :
      block3
   ...
   default: block0
}
@[code]
Namely, Dao allows one case entry to have multiple values.
In this way, @[cyan]block3@[cyan] will be executed for case values @[cyan]C1,C2@[cyan] and @[cyan]C3@[cyan].
As a simple example,
@[code(dao)]
a = "a";
switch( a ){
  case 1, "a" : io.write("case 1 or a");
  default :  io.write("case default");
}
@[code(dao)]


Dao also allows the use of a value range represented as @[cyan]start ... end@[cyan] as case entry,
so that the corresponding code block is executed if the value in switch
falls inside the range. Please note that, the range includes the boundary values,
and if the ranges of different case entries overlaps, the entry with the lowest @[cyan]start@[cyan]
value is used when the switch value belongs to mulitple overlapping ranges.
@[code(dao)]
switch( 5 ){
case 1 ... 5 : io.writeln( 'case 1-5' );
case 5 ... 10 : io.writeln( 'case 5-10' );
case 10 ... 11 : a = 1;
}
@[code(dao)]





@[subsection]
Break and Skip
@[subsection]




@[text]








################################################################################
################################################################################
######## Routine
################################################################################
################################################################################

@[name]
dao.tutorial.routine
@[name]

@[title]
Dao Routine (Function)
@[title]

@[text]

Routine is a block of codes, once defined, can be used in different places
at different time repeatedly. It can accept parameters to changes its
behaviour. It may also return results to its callee.



@[subsection]Definition@[subsection]

Dao routines are declared with keyword @[green]routine@[green]
or @[green]function@[green] or @[green]sub@[green] (which is exactly equivalent to @[green]routine@[green]),

@[code(dao)]
routine func( a, b )
{
   io.writeln( a, b );
   a = 10;
   b = "test";
   return a, b; # return more than one results.
}

r1, r2;
( r1, r2 ) = func( 111, "AAA" );
r3 = func( r1, r2 );
io.writeln( "r1 = ", r1 );
io.writeln( "r2 = ", r2 );
io.writeln( "r3 = ", r3 );
@[code(dao)]



@[subsection]Named Parameter@[subsection]

In Dao the function parameters are named, and parameter values can be passed in by name:
@[code]
func( b => 123, a => "ABC" );
@[code]



@[subsection]Parameter Type and Default Value@[subsection]

It is also possible to specify the type or the default value of a parameter.
@[code]
routine MyRout( name : string, index = 0 )
{
   io.writeln( "NAME  = ", name )
   io.writeln( "INDEX = ", index )
}
@[code]
Here @[cyan]name@[cyan] is specified as string, and @[cyan]index@[cyan] is specified as number with default value 0.
If a routine is called with wrong type of parameters, or no value is passed to a parameter without a
default value, an exception will be issued and the execution will abort.


Default value can be defined for a parameter before another parameter which does not have default
value. In this case, if you want to use the default value for that parameter with default value,
you need to pass value by name to the parameter without default value:
@[code]
routine MyRout2( i=0, j ){ io.writeln( i, " ", j ) }
MyRout2( j => 10 )
@[code]



@[subsection]Constant Parameter@[subsection]

Constant parameter can be specified by adding "const" in front
of the parameter type:
@[code]
routine Test( a : const list<int> )
{
  a[1] = 100; # error !!!
  io.writeln( a );
}
a = { 1, 2, 3 }
Test( a );
@[code]



@[subsection]Parameter Passing by Reference@[subsection]

Parameter passing by reference can be done by adding @[green]&@[green]
in front of a parameter. Only local variables of primitive types 
can be passed as references, and references can be only created in parameter list.
@[code]
routine Test( p : int )
{
	p += p;
}
i = 10;
Test( & i );
io.writeln( i );
@[code]



@[subsection]Parameter Grouping@[subsection]

Dao also supports parameter grouping as in Python.
Parameter grouping is defined by putting a pair of parenthesis
around one or more parameters in a function prototype.
When a tuple is passed as parameter to a function with parameter grouping
in the corresponding position, and if the items of the tuple have types 
compatible to those parameters in the grouping, the tuple will be expanded
with items passed as corresponding parameters.

@[code]
routine Test( a : int, ( b : string, c = 0 ) )
{
  io.writeln( a, b, c );
}
t = ( 'abc', 123 )
Test( 0, t )
@[code]



@[subsection]Routine Overloading@[subsection]

Routine overloading by parameter types is also supported in Dao,
which means that multiple routines can be defined with the same name,
but different parameters.
@[code]
routine MyRout( index : int, name = "ABC" )
{
   io.writeln( "INDEX = ", index )
   io.writeln( "NAME  = ", name )
}

MyRout( "DAO", 123 ) # invoke the first MyRout()
MyRout( 456, "script" ) # invoke the second MyRout()
@[code]



@[subsection]Routine As First Class Object@[subsection]

Dao also support first class functions / routines. They can be created in the following way:
@[code]
foo = routine( x, y : TYPE, z = DEFAULT )
{
   codes;
}
@[code]
The definition of such functions is identical to the normal function definition, except
the following differences:
@[list]
==there is no need for a function name, but the created function must be assigned to a variable;
==the default value expressions for parameters do not necessary to be constant expressions,
they are evaluated at running time when the function is created;
==the function body may contain variables defined in the "upper" function that creates it;
depending on the type of the "upper" variable, its copy (for simple types) 
or reference will be used by the created function.
@[list]


Here is an example,
@[code]
a = "ABC";

rout = routine( x, y : string, z = a+a ){
    a += "_abc";
    io.writeln( "lambda ", a )
    io.writeln( "lambda ", y )
    io.writeln( "lambda ", z )
}

rout( 1, "XXX" );
@[code]



@[subsection]Generator and Coroutine@[subsection]

If the function name is prefixed with @[green]@@[green] when it is called,
this call will return a generator or coroutine body,
so that it will yield a value or a tuple each time 
the generator or coroutine is called.
Inside the generator and coroutine, value(s) emitted by the
@[green]yield@[green] statment.
Their execution will be suspended after they @[green]yield@[green],
and when they are reseumed, they will start to execute from where
they are suspended.
The data returned by the @[green]yield@[green] statment is the parameters
passed to them when they are resumed.
When a @[green]return@[green] statment is executed or the end of the function is reached, 
the generator or coroutine will exit and become not resumable anymore.

@[code]
# int => tuple<int,int>
routine gen1( a = 0 )
{
	k = 0;
	while( k ++ < 3 ) a = yield( k, a );
	return 0,0;
}
routine gen2( a = 0 )
{
	return gen1( a );
}
g = @gen2( 1 );
# parameters can be omitted the first time it's called;
# the first call may use the parameters 
# that are used for creating the generator:
io.writeln( 'main1: ', g() );
io.writeln( 'main2: ', g( 100 ) );
io.writeln( 'main3: ', g( 200 ) );
@[code]
@[code]
routine foo( a = 0, b = '' )
{
	io.writeln( 'foo:', a );
	return yield( 2 * a, 'by foo()' );
}

routine bar( a = 0, b = '' )
{
	io.writeln( 'bar:', a, b );
	( r, s ) = foo( a + 1, b );
	io.writeln( 'bar:', r, s );
	( r, s ) = yield( a + 100, b );
	io.writeln( 'bar:', r, s );
	return a, 'ended';
}

co = @bar( 1, "a" );
   
io.writeln( 'main: ', co() );
io.writeln( 'main: ', co( 1, 'x' ) );
io.writeln( 'main: ', co( 2, 'y' ) );
# coroutine has been finished, the following will rise an exception.
io.writeln( 'main: ', co( 3, 'z' ) );
@[code]

Generators and coroutines can also be created by the standard
method @[green]stdlib.coroutine()@[green], but then the values
must be yielded by the method @[green]stdlib.yield()@[green].
Besides this, there is another important difference between these 
two ways of using generators and coroutines regarding Dao typing system.


The variables passed around by generators or coroutines created 
by prefixing the function with @[green]@@[green]
are @[green]type-checked@[green] by the typing system,
while generators and coroutines created by the @[green]stdlib.coroutine()@[green]
	method will not be type-checked.


@[text]






################################################################################
################################################################################
######## Class
################################################################################
################################################################################

@[name]
dao.tutorial.class
@[name]

@[title]
Dao Class and Object-Oriented Programming
@[title]

@[text]

Dao supports object-oriented programming (OOP) by allowing user to define
classes using keyword @[green]class@[green] and create instances of them by calling them
in the same way as calling routines. A class is simply a set
of member variables and functions,
which define the properties and possible behaviours of the class.
An instance (which is often called object) is the realization of a class
with some properties being initialized to certain values. The functions
of a class are usually used to operate on the class or its instance.
Permission modifiers @[green]private@[green], @[green]protected@[green] and @[green]public@[green] can be used to set permissions
on the variables and functions. Optionally, permission modifiers can be followed by a colon.
Class members are public by default.



@[subsection]Class Definition@[subsection]

<_>
Starting from Dao v1.1, the syntax for class definition has been changed slightly.
Now parameters and codes are not allowed in class body.
</_>

@[code]
class MyNumber
{
	private

   var value = 0;
   var name : string;

	public

   routine MyNumber( value = 0, s = "NoName" ){
     value = value;
     name = s;
   }

   routine setValue( v ){ value = v }
   routine getValue(){ return value }

   routine setValue( v : float );
}

routine MyNumber::setValue( v : float )
{
   value = v;
}
@[code]

Whenever an instance/object of a class is created, a specific routine
is invoked to initialize the object.
This kind of routine is called constructor for the class.
Unlike other languages where a constructor should be explicitly defined
as a member function of a class, the class body is the constructor
for Dao class.
Like in Python, the constructors are not used to create class instances,
instead, an instance is created before, and then the constructor is called
after to initialize the instance.


In the class body, whenever a variable is specified
with keyword @[green]var@[green], it is regarded as an instance variable.
The data type of instance variable can be set by in the following way,
@[code]
var variable : type;
@[code]
Where @[cyan]type@[cyan] must be a valid type name.
And @[cyan]variable@[cyan] will have to have the same type as @[cyan]type@[cyan],
or have to be an instance of @[cyan]type@[cyan] if it is a class.

The default value of instance variable can also be specified,
@[code]
var variable = init_value;
@[code]
Where @[cyan]init_value@[cyan] must also be a constant.


Within class methods, the special variable @[green]self@[green] represents the current class
instance. Class methods may be declared inside class body and defined outside
in the same way as in C++, but in Dao, one should make sure that, the parameter list
must be exactly the same in the places for declaration and definition.
If no instance variable is used in a method, this method can be invoked with class
by @[cyan]class.method(...)@[cyan].


Like in C++, virtual method can be declared by adding keyword @[green]virtual@[green]
before the @[green]routine@[green] or @[green]function@[green] keyword.



@[subsection]Class Instance@[subsection]

Class instance can be created by invoking the constructor of the class in the same way as
a function call,
@[code]
obj1 = MyNumber(1);
@[code]
Class instance may also be created by enumerating the members of a class,
@[code]
obj2 = MyNumber{ 2, "enumerated" };
@[code]
The names of instance variables may also be specified in enumeration,
@[code]
obj3 = MyNumber{
   name  => "enumerated";
   value => 3;
};
@[code]

When you create a class instance using enumeration, the instance is created,
and filled with the values in the enumeration.
Instance creation by enumeration is much faster than creation by invoking class constructor,
since no class constructor is called and there is no overhead associated with function call
(parameter passing, running time context preparation for the call etc.).
So such instance creation is very desirable for creating many instances for simple classes,
in which there are no complicated initialization operations.



@[subsection]Member Variable@[subsection]

As mentioned above, instance variables are declared in class constructor
using @[green]var@[green] keyword. 
Class constant can be declared using @[green]const@[green] keyword,
and static member can be declared using @[green]static@[green] keyword as in C++:
@[code]
class Klass
{
   const aClassConst = "KlassConst";
   static aClassStatic;
}
@[code]
Here @[cyan]aClassConst@[cyan] will be constant belonging to a @[cyan]Klass@[cyan].
While @[cyan]aClassStatic@[cyan] will be a static variable in the class scope.



@[subsection]Setters, Getters and Overloadable Operators@[subsection]

Instead of defining @[cyan]setXyz()@[cyan] methods, one can define @[cyan].Xyz=()@[cyan] method
as setter operator,
so that modifying class member @[cyan]Xyz@[cyan] by @[cyan]obj.Xyz=abc@[cyan] will be allowed;
similarly, if @[cyan].Xyz()@[cyan] is defined, get the value by @[cyan]obj.Xyz@[cyan] will also
be allowed:
@[code(dao)]
class MyNumber0
{
	private
   
	var value = 0;

	public

  routine MyNumber0( v = 0 ){
    value = v;
  }

  operator .value=( v ){ value = v; io.writeln( "value is set" ) }
  operator .value(){ return value }
}

num = MyNumber0( 123 )
num.value = 456
io.writeln( num.value )
@[code(dao)]

@[cyan]As you may guess, accessing instance variable through getters and setters are much more expensive
than using them as public variables!
They should be used only when they make things more convenient
(for example, when you want them to do extra work when a variable is accessed).
@[cyan]

Other supported operators for overloaing include:
@[list]
==[operator =(...)] for assignment;
==[operator ()(...)] for function call;
==[operator [](...)] for getting item(s);
==[operator []=(...)] for setting item(s);
@[list]
Other operators will be supported in the future versions.



@[subsection]Method Overloading@[subsection]

Class methods can be overloaded in the same way as normal functions.
Class constructor may also be overloaded by simply adding a method with the same name
as the class. 
For example, class @[cyan]MyNumber@[cyan] can be modified to hold numeric value only:
@[code(dao)]
class MyNumber
{
	private

   var value : int = 0;

	public

  routine MyNumber( value = 0 ){ # accept integer as parameter
    self.value = value;
  }

   # overloaded constructor to accept MyNumber as parameter:
   routine MyNumber( value : MyNumber ){ self.value = value.value }

   operator .value=( v : int ){ value = v }
   operator .value=( v : MyNumber ){ value = v.value }
   operator .value(){ return value }
}

num1 = MyNumber( 123 )
num1.value = 456
io.writeln( num1.value )

num2 = MyNumber( num1 )
io.writeln( num2.value )

num2.value = 789
io.writeln( num2.value )

num2.value = num1
io.writeln( num2.value )
@[code(dao)]



@[subsection]Inheritance@[subsection]
@[code]
class ColorRBG
{
   var Red = 0;
   var Green = 0;
   var Blue = 0;

   routine ColorRBG( r, g, b ){
     Red = r;
     Green = g;
     Blue = b;
   }

   routine setRed( r ){ Red = r; }
   routine setGreen( g ){ Green = g; }
   routine setBlue( b ){ Blue = b; }

   routine getRed(){ return Red; }
   routine getGreen(){ return Green; }
   routine getBlue(){ return Blue; }
}

yellow = ColorRBG( 255, 255, 0 ); # create an instance.
@[code]
The following will define a derived class of @[cyan]ColorRBG@[cyan],
@[code]
class ColorQuad : ColorRBG
{
   var alpha = 0; # alpha component for tranparency.

   routine ColorQuad( r, g, b, a ) : ColorRBG( r, g, b ){
     alpha = a;
   }
}

yellow2 = ColorQuad( 255, 255, 0, 0 ); # not tranparent.
yellow2.alpha = 127; # change to half tranparency.
@[code]

In the definition of derived class,
the parent class @[cyan]ColorRBG@[cyan] should be put after the derived class 
and be separated with @[green]:@[green]. If there are more than
one parent classes, separate them with @[green],@[green]. The parameters for derived class
can be passed to parent classes in the way as shown in the example.


Derived class will automatically inherit constructors from its parent class,
if it has only one parent class, and there is no redefined constructors with
signatures the same as those to be inherited.



@[text]












################################################################################
################################################################################
######## Class
################################################################################
################################################################################

