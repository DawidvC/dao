load help;

@[name]
dao.concurrent
@[name]

@[title]
Concurrent Programming
@[title]

@[text]

Dao has native support for concurrent programming on multicore computers.
The basic concurrent computational unit in Dao is a tasklet which consists
of a virtual machine process (context) and a future value (handle).
A tasklet is much cheaper than a native thread, because only active tasklets
are attached to native threads for execution.


Dao provides two main features for concurrent programming:
one is the multithreading module @[green]mt@[green];
the other is the asynchronous class.
Dao also provides communication channels for tasklets 
to communicate and synchronize with each other by channels.
@[text]


################################################################################
################################################################################
#### Multithreading
################################################################################
################################################################################
@[name]
dao.concurrent.threading
@[name]
@[title]
Multithreading Module
@[title]

@[text]

The multithreading module @[green]mt@[green] offers methods 
for creating tasklets and synchronization constructs such as
mutex, condition variable, semaphore and as well as channels.
This module also provides a list of parallelized methods that
can make some typical parallelization tasks straightforward.


@[section]
Starting Tasklet
@[section]

The simplest way to start a tasklet is to use the functional method
@[green]mt.start@[green] to run an expression or a block of codes:
@[code]
a = 123
fut = mt.start::{ a*a }
fut2 = mt.start::{
	for( i = 1 : 1000 ) b = a*a
}
@[code]
This functional method is implemented as a code section (code block as in Ruby)
method, and can take a block of code as an additional implicit parameter.
@[green]mt.start@[green] returns the created tasklet in the form of a future value.
The created tasklet may be executed by a reused thread from the internal
thread pool or by a newly created thread.
The future value for the tasklet can be used to perform simple scheduling
such as blocking the current thread indefinitely or a finite amount of time
to wait for the thread to finish. For example,
@[code]
fut.wait()
fut2.wait( 0.1 )
@[code]


@[section]
Using Parallelized Code Block Methods
@[section]

However, the simplest way to do parallel programming is to use the
parallelized functional methods of @[green]mt@[green], which provides
the following parallelized functional methods,
@[list]
-- @[green]iterate()@[green]:

   Iterate a predefined number of times, or iterate over a list, map or array,
   and execute the code block on each of the items;

-- @[green]map()@[green]

   Map a list, map or array to another list, map or array, using the values
   returned by the code block;

-- @[green]apply()@[green]

   Apply the values returned by the code block to a list, map or array;

-- @[green]find()@[green]

   Find the first item in a list or map the satisfy the condition as
   tested by the code block.
@[list]

Examples,
@[code]
mt.iterate( 10 )::{ io.writeln( X ) }
mt.iterate( {1,2,3,4,5,6}, 3 )::{ io.writeln( X ) }
@[code]



@[section]
Synchronization by Mutex, Conditional Variable and Semaphore
@[section]

Mutex, conditional variable and semaphore are the convetional way
for thread synchronization. They are provided by @[green]mt@[green]
module for convenience. But these constructs synchronize tasklet
by block the native threads, so they are not the recommended way
for synchronization and communication channels are the preferrable way.


@[subsection]Mutex@[subsection]

Mutex can be used to synchronize the accessing of shared data structures.
It has two state: locked and unlocked. A mutex can be locked by only one
thread. A thread is suspended when it attempt to lock a mutex which has
been locked by another thread. Mutex can be created by 
the @[green]mt@[green] library object,
@[code(dao)]
mutex = mt::mutex();
@[code(dao)]
Then it can be locked or unlocked by,
@[code(dao)]
mutex.lock();
mutex.unlock();
mutex.trylock();
@[code(dao)]
By calling @[cyan]lock()@[cyan], the calling thread will be block if the mutex is
already locked by another thread. If the mutex is locked by the same thread,
a second calling of @[cyan]lock()@[cyan] may cause a deadlock. @[cyan]trylock()@[cyan] is the same
as @[cyan]lock()@[cyan] except that it will return immediately instead of blocking
the calling thread if the mutex is already locked.


@[subsection]Condition Variable@[subsection]

Condition variable is a synchronization device which allow a thread to be
suspended if a condition is not satisified and resume execution when
it is signaled. The basic operations on a condition is: wait on the condition,
or signal the condition.
@[code(dao)]
condvar = mt::condition();
@[code(dao)]

Condition variable should always be used together
with a mutex. To wait on a condition,
@[code(dao)]
mtx.lock()
condvar.wait( mtx );
mtx.unlock();
@[code(dao)]

To wait on a condition for a maximum time,
@[code(dao)]
mtx.lock()
condvar.timedwait( mtx, seconds );
mtx.unlock();
@[code(dao)]

@[cyan]seconds@[cyan] can be a decimal, for example, @[cyan]condvar.timedwait( mtx, 0.005 )@[cyan]
will wait for five miliseconds.


@[subsection]Semaphore@[subsection]

Semaphore can be used to set a limit on resources. It maintains a count
for the resource, and allows a thread to proceed, when it attempts to
decrease a non-zero count. If the count already reaches 0 before the
decrement, the thread will be suspended until the count becomes non-zero.
When the thread finished using the resource, it should increase the count
of semaphore. A semaphore must be created with an initial count,
@[code(dao)]
sema = mt::semaphore( count );
@[code(dao)]

To access a resource guarded by a semaphore, use,
@[code(dao)]
sema.wait()
@[code(dao)]
If the resource is acquired, the count of @[cyan]sema@[cyan] will be decreased.

To release the resource, use
@[code(dao)]
sema.post()
@[code(dao)]
which will increase the count.


@[text]





################################################################################
################################################################################
#### Asynchronous Class
################################################################################
################################################################################
@[name]
dao.concurrent.asyncall
@[name]

@[title]
Asynchronous Function Call
@[title]

@[text]

Asynchronous Function Call (AFC) allows a function call to be executed
as a tasklet, and return immediately a future value that can be use to block on
the tasklet and wait for its completion.


Any standard function call followed by @[green]!!@[green] will start an AFC.
@[code]
routine MyFunction( n = 10 )
{
	for( i = 1 : n ) io.writeln( i )
}
f = MyFunction( 20 ) !!
io.writeln( f.value() )
@[code]
@[text]




################################################################################
################################################################################
#### Asynchronous Class
################################################################################
################################################################################
@[name]
dao.concurrent.asynclass
@[name]

@[title]
Asynchronous Class
@[title]

@[text]

Asynchronous class is a class whose instance methods will be executed asynchronously, 
namely, calling a method on an instance object of such class will return a future value 
immediately, and the execution will be started in different thread. 
Such executions are scheduled such that only one method is actively executed 
for any single object at any time, namely, multiple executions on the same object 
are mutually exclusive.


So each instance of an asynchronous class act just like a monitor,
but it also acts like an actor in the actor model considering that calling methods
of such instance is just like sending messages to the instance with function parameters
being the message contents. For each instance, these messages are processed one by one
in the order of receiving.


Defining an asynchronous class is very much like defining a normal class,
but with the following restrictions:
@[list]
--It cannot contain public data field;
--It cannot derive from normal class (and vice versa);
@[list]
Preceeding the class name with @[green]@@[green] defines an asynchronous class.
In other places, the class name should be used without the @[green]@@[green] prefix.
Here is an simple example,
@[code]
class @Account
{
	private

	var balance = 0

	public

	routine Account( init = 0 ){
		balance = init
	}
	routine Withdraw( amount : int ) => enum<false,true>
	{
		if ( balance < amount ) return $false
		balance -= amount
		return $true
	}
	routine Deposit( amount : int ) => int
	{
		balance += amount
		return balance
	}
	routine Balance() => int
	{
		return balance
	}
}

acount1 = Account( 100 )
acount2 = Account( 100 )

future1 = acount1.Withdraw( 10 )
if( future1.value() == $true ) future2 = acount2.Deposit( 10 )

future3 = acount1.Deposit( 20 )

io.writeln( 'Balance in account1:', acount1.Balance().value() )
io.writeln( 'Balance in account2:', acount2.Balance().value() )
@[code]

Like calling @[green]mt.start()@[green], calling a method on an asynchronous
class instance will return a future value, which can be used to check the
status of the asynchronous call.


@[text]



################################################################################
################################################################################
#### Channels
################################################################################
################################################################################

@[name]
dao.concurrent.channel
@[name]

@[title]
Communication Channel
@[title]

@[text]

Both @[green]mt::start@[green] and the methods of asynchronous class
run as tasklets (represented by future values) that can be assigned
to native threads to run concurrently.
Tasklets can communicate and synchronize with each other using 
@[green]communication channels@[green].


The @[green]channel@[green] type is implemented as a customized C data type
that supports template-like type arguments. So to construct a channel that 
can send and receive integers, one can use,
@[code]
chan = mt::channel<int>()
@[code]
Here @[magenta]channel@[magenta] is prefixed with @[magenta]mt::@[magenta],
because @[green]channel@[green] is defined in the built-in @[green]mt@[green]
multi-threading module.


The type argument @[magenta]int@[magenta] indicates this channel can only
be used to transmit integers. Currently, only primitive types 
(@[green]int@[green], @[green]float@[green], @[green]double@[green], 
@[green]complex@[green], @[green]string@[green], @[green]enum@[green]) 
plus @[green]array@[green] types, and their composition through 
@[green]list@[green], @[green]map@[green] and @[green]tuple@[green] 
types are supported for channels. 


Each channel has a capacity for transmitting data, which are buffered in the channel. 
When the channel's buffer reached its capacity, any attempt to send data to it 
will result in the blocking of the sender, which will be resumed either after 
a timeout or after some data of the channel have been read out of the buffer 
to make room for the new data being sent by the blocked sender. 
Channel capacity can be passed to the constructor of the channel as 
an optional parameter, which is one by default.


The channel type has a number of methods which include:
@[list]
--@[code(dao)]buffer( self :channel<@V> ) => int@[code(dao)]

It returns the number of unprocessed data items in the channel buffer.

--@[code(dao)] cap( self :channel<@V> ) => int @[code(dao)]

Return the channel capacity.

--@[code(dao)] cap( self :channel<@V>, cap :int ) => int @[code(dao)]

Set the channel capacity and returns the previous one. Set the capacity to zero to prevent it from receiving further data, and effectively close it when its buffer become empty.

--@[code(dao)] send( self :channel<@V>, data :@V, timeout :float = -1 ) => int @[code(dao)]

Send a data item with a timeout. A negative timeout parameter means infinite waiting. It return 1 upon timeout, 0 otherwise.

--@[code(dao)] receive( self :channel<@V>, timeout :float = -1 ) => tuple<data :@V|none, status :enum<received,timeout,finished>> @[code(dao)]

Receive a data item with a timeout. A negative timeout parameter means infinite waiting. It returns a tuple with the following possible values:
 @[list(sub)]
 -- (data, $received);
 -- (none, $timeout);
 -- (none, $finished);
 @[list(sub)] 

--@[code(dao)] select( group :list<@T>, timeout = -1.0 ) => tuple<selected: none|@T, value :any, status :enum<selected,timeout,finished>> @[code(dao)]

Select on a group of channels, wait with a timeout for data become available from any of the channels. It returns a tuple with the following possible values:
 @[list(sub)]
 -- (channel, data, $selected);
 -- (none, none, $timeout);
 -- (none, none, $finished);
 @[list(sub)] 
As the signature indicates, this is a static method.

@[list]

Here is a simple example, where integers are sent through one channel and strings through another, and these integers and strings are received using the select method:
@[code(dao)]
load sys

chans = { mt::channel<int>(1), mt::channel<string>(1) }

mt.start::{
    index = 0;
    while( ++index <= 10 ){
        if( rand(2) ){
            io.writeln( "sending integer:", index );
            chans[0].send( index )
        }else{
            io.writeln( "sending string: S" + (string) index );
            chans[1].send( 'S' + (string) index )
        }   
        sys.sleep(0.5)
    }   
    # set channel buffer sizes to zero to close them:
    chans[0].cap(0) 
    chans[1].cap(0)
}

while( 1 ){
    data = mt::channel::select( chans, 0.2 )
    io.writeln( "received:", data );
    if( data.status == $finished ) break
}
@[code(dao)]

@[text]
