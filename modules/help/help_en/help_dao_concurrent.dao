load help;

@[name]
dao.concurrent
@[name]

@[title]
Concurrent Programming
@[title]


################################################################################
################################################################################
#### Multi-threading
################################################################################
################################################################################
@[name]
dao.concurrent.multi-threading
@[name]
@[title]
Multi-threading
@[title]

@[text]
Dao has built-in support for multi-threaded programming.
The threading functionalities are accessible through the multi-threading module
object named @[green]mt@[green], which can be used to create thread,
mutex, condition variable and semaphore etc, and can be used to
perform other thread related operations.


The simplest way to start a thread is to use the functional method
@[green]mt.start@[green], which can start a new thread or reuse an idle
thread from a thread pool to run an expression or a block of codes:
@[code]
a = 123
fut = mt.start::{ a*a }
fut2 = mt.start::{
	for( i = 1 : 1000 ) b = a*a
}
@[code]
This functional method is implemented as a code section (code block as in Ruby)
method, and can take a block of code as an additional implicit parameter.
@[green]mt.start@[green] returns the created or reused thread as a
@[green]future@[green] value, which can be used to perform simple scheduling
such as blocking the current thread indefinitely or a finite amount of time
to wait for the thread to finish. For example,
@[code]
fut.wait()
fut2.wait( 0.1 )
@[code]


However, the simplest way to do threaded programming is to use the
parallelized functional methods of @[green]mt@[green], which provides
the following parallelized functional methods,
@[list]
-- @[green]iterate()@[green]:

   Iterate a predefined number of times, or iterate over a list, map or array,
   and execute the code block on each of the items;

-- @[green]map()@[green]

   Map a list, map or array to another list, map or array, using the values
   returned by the code block;

-- @[green]apply()@[green]

   Apply the values returned by the code block to a list, map or array;

-- @[green]find()@[green]

   Find the first item in a list or map the satisfy the condition as
   tested by the code block.
@[list]

Examples,
@[code]
mt.iterate( 10 )::{ io.writeln( X ) }
mt.iterate( {1,2,3,4,5,6}, 3 )::{ io.writeln( X ) }
@[code]
@[text]


################################################################################
################################################################################
#### Asynchronous Class
################################################################################
################################################################################
@[name]
dao.concurrent.asynchronous-class
@[name]

@[title]
Asynchronous Class
@[title]

@[text]
In addtion to the threading functionalities provided by @[green]mt@[green],
Dao allows user 
@[text]



################################################################################
################################################################################
#### Channels
################################################################################
################################################################################

@[name]
dao.concurrent.channel
@[name]

@[title]
Tasklet Communication Channel
@[title]

@[text]

Both @[green]mt::start@[green] and the methods of asynchronous class
run as tasklets (represented by future values) that can be assigned
to native threads to run concurrently.
Tasklets can communicate and synchronize with each other using 
@[green]communication channels@[green].


The @[green]channel@[green] type is implemented as a customized C data type
that supports template-like type arguments. So to construct a channel that 
can send and receive integers, one can use,
@[code]
chan = mt::channel<int>()
@[code]
Here @[magenta]channel@[magenta] is prefixed with @[magenta]mt::@[magenta],
because @[green]channel@[green] is defined in the built-in @[green]mt@[green]
multi-threading module.


The type argument @[magenta]int@[magenta] indicates this channel can only
be used to transmit integers. Currently, only primitive types 
(@[green]int@[green], @[green]float@[green], @[green]double@[green], 
@[green]complex@[green], @[green]string@[green], @[green]enum@[green]) 
plus @[green]array@[green] types, and their composition through 
@[green]list@[green], @[green]map@[green] and @[green]tuple@[green] 
types are supported for channels. 


Each channel has a capacity for transmitting data, which are buffered in the channel. 
When the channel's buffer reached its capacity, any attempt to send data to it 
will result in the blocking of the sender, which will be resumed either after 
a timeout or after some data of the channel have been read out of the buffer 
to make room for the new data being sent by the blocked sender. 
Channel capacity can be passed to the constructor of the channel as 
an optional parameter, which is one by default.


The channel type has a number of methods which include:
@[list]
--@[code(dao)]buffer( self :channel<@V> ) => int@[code(dao)]

It returns the number of unprocessed data items in the channel buffer.

--@[code(dao)] cap( self :channel<@V> ) => int @[code(dao)]

Return the channel capacity.

--@[code(dao)] cap( self :channel<@V>, cap :int ) => int @[code(dao)]

Set the channel capacity and returns the previous one. Set the capacity to zero to prevent it from receiving further data, and effectively close it when its buffer become empty.

--@[code(dao)] send( self :channel<@V>, data :@V, timeout :float = -1 ) => int @[code(dao)]

Send a data item with a timeout. A negative timeout parameter means infinite waiting. It return 1 upon timeout, 0 otherwise.

--@[code(dao)] receive( self :channel<@V>, timeout :float = -1 ) => tuple<data :@V|none, status :enum<received,timeout,finished>> @[code(dao)]

Receive a data item with a timeout. A negative timeout parameter means infinite waiting. It returns a tuple with the following possible values:
 @[list(sub)]
 -- (data, $received);
 -- (none, $timeout);
 -- (none, $finished);
 @[list(sub)] 

--@[code(dao)] select( group :list<@T>, timeout = -1.0 ) => tuple<selected: none|@T, value :any, status :enum<selected,timeout,finished>> @[code(dao)]

Select on a group of channels, wait with a timeout for data become available from any of the channels. It returns a tuple with the following possible values:
 @[list(sub)]
 -- (channel, data, $selected);
 -- (none, none, $timeout);
 -- (none, none, $finished);
 @[list(sub)] 
As the signature indicates, this is a static method.

@[list]

Here is a simple example, where integers are sent through one channel and strings through another, and these integers and strings are received using the select method:
@[code(dao)]
load sys

chans = { mt::channel<int>(1), mt::channel<string>(1) }

mt.start::{
    index = 0;
    while( ++index <= 10 ){
        if( rand(2) ){
            io.writeln( "sending integer:", index );
            chans[0].send( index )
        }else{
            io.writeln( "sending string: S" + (string) index );
            chans[1].send( 'S' + (string) index )
        }   
        sys.sleep(0.5)
    }   
    # set channel buffer sizes to zero to close them:
    chans[0].cap(0) 
    chans[1].cap(0)
}

while( 1 ){
    data = mt::channel::select( chans, 0.2 )
    io.writeln( "received:", data );
    if( data.status == $finished ) break
}
@[code(dao)]

@[text]
