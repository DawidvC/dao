

enum DaoTypeID
{
	DAO_NONE ,
	DAO_INTEGER ,
	DAO_FLOAT ,
	DAO_DOUBLE ,
	DAO_COMPLEX ,
	DAO_LONG ,
	DAO_STRING ,
	DAO_ENUM ,
	DAO_ARRAY ,
	DAO_LIST ,
	DAO_MAP ,
	DAO_TUPLE ,
	DAO_OBJECT ,
	DAO_CDATA ,
	DAO_CLASS ,
	DAO_CTYPE ,
	DAO_INTERFACE ,
	DAO_ROUTINE ,
	DAO_PROCESS ,
	DAO_NAMESPACE ,
	DAO_VMSPACE ,
	DAO_TYPE ,
	DAO_VARIANT ,
	DAO_FUTURE ,
	DAO_MACRO ,
	DAO_CONSTANT ,
	DAO_VARIABLE ,
	DAO_ROUTBODY ,
	DAO_TYPEKERNEL ,
	DAO_CODEBLOCK ,
	DAO_PAIR ,
	DAO_PAR_NAMED ,
	DAO_PAR_DEFAULT ,
	DAO_PAR_VALIST ,

	DAO_VALTYPE ,

	DAO_ANY = (1<<6)|0,
	DAO_THT = (1<<6)|1,
	DAO_UDT = (1<<6)|2,
}

use enum DaoTypeID;


type Module = tuple<file:int,loadas:int>

type Declaration = tuple<type:int,subtype:int,dectype:int,refnum:int,host:int,field:int>

type CoreType       = tuple<tid:int,att:int,name:int>
type EnumType       = tuple<tid:int,att:int,name:int,flag:int,symbols:list<tuple<symbol:int,value:int>>>
type ContainerType  = tuple<tid:int,att:int,name:int,types:list<int>>
type VariantType    = tuple<tid:int,att:int,name:int,type:int,types:list<int>>
type ValueType      = tuple<tid:int,att:int,name:int,value:any>
type NameParamType  = tuple<tid:int,att:int,name:int,fname:int,ftype:int>
type TypeHolderType = tuple<tid:int,att:int,name:int>
type CodeBlockType  = tuple<tid:int,att:int,name:int,type:int,types:list<int>>
type RoutineType    = tuple<tid:int,att:int,name:int,dec:int,retype:int,cbtype:int,types:list<int>>
type InterfaceType  = tuple<tid:int,att:int,name:int,dec:int>
type ClassType      = tuple<tid:int,att:int,name:int,dec:int>
type InstanceType   = tuple<tid:int,att:int,name:int,dec:int>
type CtypeType      = tuple<tid:int,att:int,name:int,dec:int,types:list<int>>
type CdataType      = tuple<tid:int,att:int,name:int,dec:int,types:list<int>>

type Type = tuple<tid:int,att:int,name:int,...>



type IEEE754Double = tuple<int,int>

type NoneValue    = tuple<tid:int>
type IntValue     = tuple<tid:int,value:int>
type FloatValue   = tuple<tid:int,value1:int,value2:int>
type DoubleValue  = tuple<tid:int,value1:int,value2:int>
type ComplexValue = tuple<tid:int,real1:int,real2:int,imag1:int,imag2:int>
type LongValue    = tuple<tid:int,sign:int,digits:list<int>>
type StringValue  = tuple<tid:int,info:int,chars:list<int>>
type EnumValue    = tuple<tid:int,etype:int,value:int>
type ArrayValue   = tuple<tid:int,ntype:int,dims:list<int>,elems:list<int>>
type ListValue    = tuple<tid:int,abtype:int,items:list<int>>
type MapValue     = tuple<tid:int,abtype:int,hasing:int,items:list<int>>
type TupleValue   = tuple<tid:int,abtype:int,items:list<int>>

type CompleteInstanceValue = tuple<tid:int,flag:int,dec:int,values:list<int>>
type PartialInstanceValue  = tuple<tid:int,flag:int,dec:int,offset:int,host:int>
type DefaultInstanceValue  = tuple<tid:int,flag:int,dec:int>

type RoutineValue   = tuple<tid:int,dec:int,routype:int,hostype:int,attribs:int>

type ClassValue     = tuple<tid:int,dec:int>
type CtypeValue     = tuple<tid:int,dec:int>
type InterfaceValue = tuple<tid:int,dec:int>
type NamespaceValue = tuple<tid:int,dec:int>

type TypeValue      = tuple<tid:int,type:int>
type NamedValue     = tuple<tid:int,name:int,type:int,value:int>

type Value          = tuple<tid:int,...>



type Constant = tuple<name:int,index:int,perm:int,value:int>
type Variable = tuple<name:int,index:int,perm:int,type:int,value:int>


type TypeDecl = tuple<name:int,type:int>


type Interface = tuple<dec:int,bases:list<int>,methods:list<int>>


type Class = 
tuple<dec:int,defCstr:int,att:int,bases:list<int>,
	constants:list<Constant>,svariables:list<Variable>,
	ivariables:list<Variable>,types:list<TypeDecl>>


type Instruction = tuple<code:int,a:int,b:int,c:int>

type Routine = 
tuple<dec:int,name:int,routype:int,hostype:int,uprout:int,attribs:int,line:int,
	constants:list<int>,varCount:int,varTypes:list<tuple<index:int,type:int>>,
	lineCounts:list<tuple<line:int,count:int>>,codes:list<Instruction>>



class DaoByteCode
{
	var data = '';
	var offset = 0;
	var intSize = 4;

	var header = '';
	var source = '';

	var identifiers : list<string> = {};

	var modules : list<Module> = {};
	var declarations : list<Declaration> = {};

	var types  : list<Type> = {};
	var values : list<Value> = {};

	var constants : list<Constant> = {};
	var variables : list<Variable> = {};
	var typeDecls : list<TypeDecl> = {};

	var interfaces : list<Interface> = {};
	var classes    : list<Class> = {};
	var routines   : list<Routine> = {};

	routine DecodeUInt8()=>int;
	routine DecodeUInt16()=>int;
	routine DecodeUInt32()=>int;
	routine DecodeDaoInt()=>int;
	routine DecodeShortString()=>string;

	routine DecodeIdentifiers();
	routine DecodeModules();
	routine DecodeDeclarations();
	routine DecodeTypes();
	routine DecodeValue()=>Value;

	routine Decode( bytecodes : string );

	routine ErrorFormat(){ raise Exception::Error( 'Invalid bytecode format' ) }
}

routine DaoByteCode::DecodeUInt8()=>int
{
	i = offset;
	offset += 1;
	if( offset > data.size() ) ErrorFormat();
	return data[i];
}
routine DaoByteCode::DecodeUInt16()=>int
{
	i = offset;
	offset += 2;
	if( offset > data.size() ) ErrorFormat();
	return (data[i]<<8) + data[i+1];
}
routine DaoByteCode::DecodeUInt32()=>int
{
	i = offset;
	offset += 4;
	if( offset > data.size() ) ErrorFormat();
	return (data[i]<<24) + (data[i+1]<<16) + (data[i+2]<<8) + data[i+3];
}
routine DaoByteCode::DecodeDaoInt()=>int
{
	return 0;
}
routine DaoByteCode::DecodeShortString()=>string
{
	len = DecodeUInt16();
	i = offset;
	offset += len;
	return data[i:i+len-1];
}
routine DaoByteCode::DecodeIdentifiers()
{
	count = DecodeUInt32();
	for( i = 1 : count ) identifiers.append( DecodeShortString() )
}
routine DaoByteCode::DecodeModules()
{
	count = DecodeUInt32();
	for( i = 1 : count ) modules.append( Module{ DecodeUInt32(), DecodeUInt32() } );
}
routine DaoByteCode::DecodeDeclarations()
{
	count = DecodeUInt32();
	for( i = 1 : count ){
		otype = DecodeUInt8();
		subtype = DecodeUInt8();
		dectype = DecodeUInt8();
		name = DecodeUInt32();
		host = DecodeUInt32();
		field = DecodeUInt32();
		declarations.append( Declaration{ otype, subtype, dectype, name, host, field } );
	}
}
routine DaoByteCode::DecodeValue()=>Value
{
	tid = DecodeUInt8();
	value = Value{ tid };
	switch( tid ){
	case DAO_NONE :
	case DAO_INTEGER :
		value = IntValue{ tid, DecodeDaoInt() }
	case DAO_FLOAT ,
	case DAO_DOUBLE :
		value = FloatValue{ tid, DecodeDaoInt(), DecodeDaoInt() }
	case DAO_COMPLEX :
		i1 = DecodeDaoInt();
		i2 = DecodeDaoInt();
		i3 = DecodeDaoInt();
		i4 = DecodeDaoInt();
		value = ComplexValue{ tid, i1, i2, i3, i4 }
	case DAO_LONG :
		sign = DecodeUInt8();
		count = DecodeDaoInt();
		value2 = LongValue{ tid, count, {} };
		value = value2;
		digits = value2.digits;
		for( i = 1 : count ) digits.append( DecodeUInt8() );
	case DAO_STRING :
		flag = DecodeUInt8();
		charsize = flag & 0xF;
		count = DecodeDaoInt();
		value3 = StringValue{ tid, flag, {} };
		value = value3;
		chars = value3.chars;
		switch( charsize ){
		case 1 : for( i = 1 : count ) chars.append( DecodeUInt8() );
		case 2 : for( i = 1 : count ) chars.append( DecodeUInt16() );
		case 4 : for( i = 1 : count ) chars.append( DecodeUInt32() );
		}
	case DAO_ENUM :
		value = EnumValue{ tid, DecodeUInt32(), DecodeUInt32() }
	case DAO_ARRAY :
		ntype = DecodeUInt8()
		size = DecodeDaoInt()
		ndim = DecodeUInt16()
		value2 = ArrayValue{ tid, ntype, {}, {} }
		value = value
		dims = value2.dims
		elems = value2.elems
		switch( ntype ){
		case DAO_FLOAT   ,
		case DAO_DOUBLE  : size *= 2;
		case DAO_COMPLEX : size *= 4;
		}
		for( i = 1 : ndim ) dims.append( DecodeDaoInt() );
		for( i = 1 : size ) elems.append( DecodeDaoInt() );
	case DAO_LIST  ,
	case DAO_TUPLE :
		abtype = DecodeUInt32()
		size = DecodeDaoInt()
		value2 = ListValue{ tid, abtype, {} }
		value = value2
		items = value2.items
		for( i = 1 : size ) items.append( DecodeDaoInt() );
	case DAO_MAP :
		abtype = DecodeUInt32()
		hashing = DecodeUInt32()
		size = DecodeDaoInt()
		value2 = MapValue{ tid, abtype, hashing, {} }
		value = value2
		items = value2.items
		for( i = 1 : 2*size ) items.append( DecodeDaoInt() );
	case DAO_TYPE :
		abtype = DecodeUInt32()
		value = TypeValue{ tid, abtype }
#	case DAO_FUTURE :
	case DAO_OBJECT :
		flag = DecodeUInt8()
		dec = DecodeUInt32()
		if( flag == 0x0 ){
			num = DecodeUInt16()
			value2 = CompleteInstanceValue{ tid, flag, dec, {} }
			value = value2
			vals = value2.values
			for( i = 1 : num ) vals.append( DecodeUInt32() )
		}else if( flag == 0x1 ){
			offset = DecodeUInt16()
			host = DecodeUInt32()
			value = PartialInstanceValue{ tid, flag, dec, offset, host }
		}else{
			value = DefaultInstanceValue{ tid, flag, dec }
		}
	case DAO_CLASS ,
	case DAO_CTYPE ,
	case DAO_INTERFACE ,
	case DAO_NAMESPACE :
		dec = DecodeUInt32()
		value = ClassValue{ tid, dec }
	case DAO_CDATA :
	case DAO_ROUTINE :
	case DAO_CODEBLOCK :
	case DAO_PAR_NAMED ,
	case DAO_PAR_DEFAULT :
	case DAO_VALTYPE :
	default :
	}
	return value;
}
routine DaoByteCode::DecodeTypes()
{
	count = DecodeUInt32();
	io.writeln( count );
	for( i = 1 : count ){
		tid = DecodeUInt8();
		att = DecodeUInt8();
		name = DecodeUInt32();
		io.writef( '%5i %5i %5i\n', i, tid, name )#, identifiers[name-1] )
		io.writeln( identifiers[name-1] )
		switch( tid ){
		case DAO_NONE ,
		case DAO_INTEGER ,
		case DAO_FLOAT ,
		case DAO_DOUBLE ,
		case DAO_COMPLEX ,
		case DAO_LONG ,
		case DAO_STRING :
			types.append( CoreType{ tid, att, name } );
		case DAO_ENUM :
			subtype = DecodeUInt8();
			symcount = DecodeUInt16();
			enumType = EnumType{ tid, att, name, subtype, {} };
			symbols = enumType.symbols;
			for( j = 1 : symcount ) symbols.append( (DecodeUInt32(), DecodeUInt32()) );
			io.writeln( symbols );
			types.append( enumType );
		case DAO_ARRAY ,
		case DAO_LIST ,
		case DAO_MAP ,
		case DAO_TUPLE ,
		case DAO_TYPE ,
		case DAO_FUTURE :
			typeCount = DecodeUInt16();
			contype = ContainerType{ tid, att, name, {} };
			itypes = contype.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( contype )
		case DAO_OBJECT ,
		case DAO_CLASS ,
		case DAO_INTERFACE :
			dec = DecodeUInt32();
			types.append( InstanceType{ tid, att, name, dec } );
		case DAO_CDATA ,
		case DAO_CTYPE :
			dec = DecodeUInt32();
			typeCount = DecodeUInt16();
			tup = CdataType{ tid, att, name, dec, {} };
			itypes = tup.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( tup );
		case DAO_ROUTINE :
			dec = DecodeUInt32();
			retype = DecodeUInt32();
			cbtype = DecodeUInt32();
			typeCount = DecodeUInt16();
			tup = RoutineType{ tid, att, name, dec, retype, cbtype, {} };
			itypes = tup.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( tup );
		case DAO_VARIANT ,
		case DAO_CODEBLOCK :
			typeCount = DecodeUInt16();
			holder = DecodeUInt32();
			contype = VariantType{ tid, att, name, holder, {} };
			itypes = contype.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
		case DAO_PAR_NAMED ,
		case DAO_PAR_DEFAULT :
			fname = DecodeUInt32();
			ftype = DecodeUInt32();
			types.append( NameParamType{ tid, att, name, fname, ftype } );
		case DAO_VALTYPE :
			value = DecodeValue();
			types.append( ValueType{ tid, att, name, value } );
		default :
			types.append( CoreType{ tid, att, name } );
		}
	}
}
routine DaoByteCode::Decode( bytecodes : string )
{
# "bytecodes" could be MBS, with character range [-127,127];
# Map it to WCS, so that the character range will become [0,255];
	data = bytecodes.map::{ (X+256)%256 }

	if( data.size() < 16 ) raise Exception::Error( 'Invalid bytecode file' );
	if( data[:3] != "\33Dao" ) raise Exception::Error( 'Not a Dao bytecode file' );

	header = data[:15];

	intSize = data[9];
	offset = 16;

	source = DecodeShortString();
	DecodeIdentifiers();
	DecodeModules();
	DecodeDeclarations();
	DecodeTypes();

	io.writeln( intSize, source );
	io.writeln( identifiers.size() );
	io.writeln( modules );
	io.writeln( declarations );
	io.writeln( types );
}


routine main( file : string )
{
	coder = DaoByteCode();
	coder.Decode( io.read( file ) );
}
