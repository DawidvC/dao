

enum DaoTypeID
{
	DAO_NONE ,
	DAO_INTEGER ,
	DAO_FLOAT ,
	DAO_DOUBLE ,
	DAO_COMPLEX ,
	DAO_LONG ,
	DAO_STRING ,
	DAO_ENUM ,
	DAO_ARRAY ,
	DAO_LIST ,
	DAO_MAP ,
	DAO_TUPLE ,
	DAO_OBJECT ,
	DAO_CDATA ,
	DAO_CLASS ,
	DAO_CTYPE ,
	DAO_INTERFACE ,
	DAO_ROUTINE ,
	DAO_PROCESS ,
	DAO_NAMESPACE ,
	DAO_VMSPACE ,
	DAO_TYPE ,
	DAO_VARIANT ,
	DAO_FUTURE ,
	DAO_MACRO ,
	DAO_CONSTANT ,
	DAO_VARIABLE ,
	DAO_ROUTBODY ,
	DAO_TYPEKERNEL ,
	DAO_CODEBLOCK ,
	DAO_PAIR ,
	DAO_PAR_NAMED ,
	DAO_PAR_DEFAULT ,
	DAO_PAR_VALIST ,

	DAO_VALTYPE ,

	DAO_ANY = (1<<6)|0,
	DAO_THT = (1<<6)|1,
	DAO_UDT = (1<<6)|2,
}

use enum DaoTypeID;


type Module = tuple<file:int,loadas:int>

type Declaration = tuple<type:int,subtype:int,dectype:int,refnum:int,host:int,field:int>

type CoreType       = tuple<tid:int,att:int,name:int>
type EnumType       = tuple<tid:int,att:int,name:int,flag:int,symbols:list<tuple<symbol:int,value:int>>>
type ContainerType  = tuple<tid:int,att:int,name:int,types:list<int>>
type VariantType    = tuple<tid:int,att:int,name:int,type:int,types:list<int>>
type ValueType      = tuple<tid:int,att:int,name:int,value:any>
type NameParamType  = tuple<tid:int,att:int,name:int,fname:int,ftype:int>
type TypeHolderType = tuple<tid:int,att:int,name:int>
type CodeBlockType  = tuple<tid:int,att:int,name:int,type:int,types:list<int>>
type RoutineType    = tuple<tid:int,att:int,name:int,dec:int,retype:int,cbtype:int,types:list<int>>
type InterfaceType  = tuple<tid:int,att:int,name:int,dec:int>
type ClassType      = tuple<tid:int,att:int,name:int,dec:int>
type InstanceType   = tuple<tid:int,att:int,name:int,dec:int>
type CtypeType      = tuple<tid:int,att:int,name:int,dec:int,types:list<int>>
type CdataType      = tuple<tid:int,att:int,name:int,dec:int,types:list<int>>

type Type = tuple<tid:int,att:int,name:int,...>



type IEEE754Double = tuple<int,int>

type NoneValue    = tuple<tid:int>
type IntValue     = tuple<tid:int,value:int>
type FloatValue   = tuple<tid:int,value1:int,value2:int>
type DoubleValue  = tuple<tid:int,value1:int,value2:int>
type ComplexValue = tuple<tid:int,real1:int,real2:int,imag1:int,imag2:int>
type LongValue    = tuple<tid:int,sign:int,digits:list<int>>
type StringValue  = tuple<tid:int,info:int,chars:list<int>>
type EnumValue    = tuple<tid:int,etype:int,value:int>
type ArrayValue   = tuple<tid:int,ntype:int,dims:list<int>,elems:list<int>>
type ListValue    = tuple<tid:int,abtype:int,items:list<int>>
type MapValue     = tuple<tid:int,abtype:int,hasing:int,items:list<int>>
type TupleValue   = tuple<tid:int,abtype:int,items:list<int>>

type CompleteInstanceValue = tuple<tid:int,flag:int,dec:int,values:list<int>>
type PartialInstanceValue  = tuple<tid:int,flag:int,dec:int,offset:int,host:int>
type DefaultInstanceValue  = tuple<tid:int,flag:int,dec:int>

type RoutineValue   = tuple<tid:int,dec:int,routype:int,hostype:int,attribs:int>

type ClassValue     = tuple<tid:int,dec:int>
type CtypeValue     = tuple<tid:int,dec:int>
type InterfaceValue = tuple<tid:int,dec:int>
type NamespaceValue = tuple<tid:int,dec:int>

type FutureValue    = tuple<tid:int,value:int>
type TypeValue      = tuple<tid:int,type:int>
type NamedValue     = tuple<tid:int,name:int,type:int,value:int>

type Value          = tuple<tid:int,...>



type Constant = tuple<name:int,index:int,perm:int,value:int>
type Variable = tuple<name:int,index:int,perm:int,type:int,value:int>


type TypeDecl = tuple<name:int,type:int>


type Interface = tuple<dec:int,bases:list<int>,methods:list<int>>


type Class = 
tuple<dec:int,defCstr:int,att:int,bases:list<int>,
	constants:list<Constant>,svariables:list<Variable>,
	ivariables:list<Variable>,types:list<TypeDecl>>


type Instruction = tuple<code:int,a:int,b:int,c:int>

type Routine = 
tuple<dec:int,name:int,routype:int,hostype:int,uprout:int,attribs:int,line:int,
	constants:list<int>,varCount:int,varTypes:list<tuple<index:int,type:int>>,
	lineCounts:list<tuple<line:int,count:int>>,codes:list<Instruction>>



class DaoByteCode
{
	var data = '';
	var offset = 0;
	var intSize = 4;

	var header = '';
	var source = '';

	var identifiers : list<string> = {};

	var modules : list<Module> = {};
	var declarations : list<Declaration> = {};

	var types  : list<Type> = {};
	var values : list<Value> = {};

	var constants : list<Constant> = {};
	var variables : list<Variable> = {};
	var typeDecls : list<TypeDecl> = {};

	var interfaces : list<Interface> = {};
	var classes    : list<Class> = {};
	var routines   : list<Routine> = {};

	routine DecodeUInt8()=>int;
	routine DecodeUInt16()=>int;
	routine DecodeUInt32()=>int;
	routine DecodeDaoInt()=>int;
	routine DecodeShortString()=>string;

	routine DecodeIdentifiers();
	routine DecodeModules();
	routine DecodeDeclarations();
	routine DecodeTypes();
	routine DecodeValues();
	routine DecodeConstants();
	routine DecodeVariables();
	routine DecodeGlobalTypes();
	routine DecodeInterfaces();
	routine DecodeClasses();
	routine DecodeRoutines();

	routine DecodeConstant()=>Constant;
	routine DecodeVariable()=>Variable;
	routine DecodeValue()=>Value;

	routine Decode( bytecodes : string );

	routine ErrorFormat(){ raise Exception::Error( 'Invalid bytecode format' ) }
}

routine DaoByteCode::DecodeUInt8()=>int
{
	i = offset;
	offset += 1;
	if( offset > data.size() ) ErrorFormat();
	return data[i];
}
routine DaoByteCode::DecodeUInt16()=>int
{
	i = offset;
	offset += 2;
	if( offset > data.size() ) ErrorFormat();
	return (data[i]<<8) + data[i+1];
}
routine DaoByteCode::DecodeUInt32()=>int
{
	i = offset;
	offset += 4;
	if( offset > data.size() ) ErrorFormat();
	return (data[i]<<24) + (data[i+1]<<16) + (data[i+2]<<8) + data[i+3];
}
routine DaoByteCode::DecodeDaoInt()=>int
{
	routine ErrorTooBigInt(){ raise Exception::Error( 'Too big integer' ) }

	sizeofInt = std.datasize( 0 )
	if( offset + intSize > data.size() ) ErrorFormat()
	B1 = data[offset+0];
	B2 = data[offset+1];
	B3 = data[offset+2];
	B4 = data[offset+3];
	if( intSize > sizeofInt ){
		B5 = data[offset+4];
		B6 = data[offset+5];
		B7 = data[offset+6];
		B8 = data[offset+7];
		offset += intSize;
		if( (B1 == 0x7F || B1 == 0xFF) && B2 == 0xFF && B3 == 0xFF && B4 == 0xFF ){
			if( B5 & 0x80 ) ErrorTooBigInt();
			if( B1 == 0xFF ) B5 |= 0x80;
		}else if( B1 || B2 || B3 || B4 ){
			ErrorTooBigInt()
		}
		return (B5<<24)|(B6<<16)|(B7<<8)|B8;
	}else if( intSize < sizeofInt ){
		offset += intSize;
		if( B1 & 0x80 ){
			leading = (0xFF<<24)|(0xFF<<16)|(0xFF<<8)|0xFF;
			return (leading<<32)|(0xFF<<24)|((B1&0x7F)<<24)|(B2<<16)|(B3<<8)|B4;
		}
		return (B1<<24)|(B2<<16)|(B3<<8)|B4;
	}

	value = 0;
	for( i = 1 : intSize ){
		value |= data[offset+i-1] << (8*(intSize-i)); # XXX: precedence a << b*c;
		#io.writeln( value, data[offset+i-1], 8*(intSize-i) );
	}
	offset += intSize;
	return value;
}
routine DaoByteCode::DecodeShortString()=>string
{
	len = DecodeUInt16();
	i = offset;
	offset += len;
	return '' + data[i:i+len-1];
}
routine DaoByteCode::DecodeIdentifiers()
{
	count = DecodeUInt32();
	for( i = 1 : count ) identifiers.append( DecodeShortString() )
}
routine DaoByteCode::DecodeModules()
{
	count = DecodeUInt32();
	for( i = 1 : count ) modules.append( Module{ DecodeUInt32(), DecodeUInt32() } );
}
routine DaoByteCode::DecodeDeclarations()
{
	count = DecodeUInt32();
	for( i = 1 : count ){
		otype = DecodeUInt8();
		subtype = DecodeUInt8();
		dectype = DecodeUInt8();
		name = DecodeUInt32();
		host = DecodeUInt32();
		field = DecodeUInt32();
		declarations.append( Declaration{ otype, subtype, dectype, name, host, field } );
	}
}
routine DaoByteCode::DecodeValue()=>Value
{
	tid = DecodeUInt8();
	io.writeln( 'value tid:', tid )
	value = Value{ tid };
	switch( tid ){
	case DAO_NONE :
	case DAO_INTEGER :
		value = IntValue{ tid, DecodeDaoInt() }
	case DAO_FLOAT ,
	case DAO_DOUBLE :
		io.writeln( offset )
		value = FloatValue{ tid, DecodeUInt32(), DecodeUInt32() }
		io.writeln( offset )
		io.writeln( value )
	case DAO_COMPLEX :
		i1 = DecodeUInt32();
		i2 = DecodeUInt32();
		i3 = DecodeUInt32();
		i4 = DecodeUInt32();
		value = ComplexValue{ tid, i1, i2, i3, i4 }
	case DAO_LONG :
		sign = DecodeUInt8();
		count = DecodeDaoInt();
		value2 = LongValue{ tid, count, {} };
		value = value2;
		digits = value2.digits;
		for( i = 1 : count ) digits.append( DecodeUInt8() );
	case DAO_STRING :
		flag = DecodeUInt8();
		charsize = flag & 0xF;
		count = DecodeDaoInt();
		value3 = StringValue{ tid, flag, {} };
		value = value3;
		chars = value3.chars;
		io.writeln( charsize, count )
		switch( charsize ){
		case 1 : for( i = 1 : count ) chars.append( DecodeUInt8() );
		case 2 : for( i = 1 : count ) chars.append( DecodeUInt16() );
		case 4 : for( i = 1 : count ) chars.append( DecodeUInt32() );
		}
	case DAO_ENUM :
		value = EnumValue{ tid, DecodeUInt32(), DecodeUInt32() }
	case DAO_ARRAY :
		ntype = DecodeUInt8()
		size = DecodeDaoInt()
		ndim = DecodeUInt16()
		value2 = ArrayValue{ tid, ntype, {}, {} }
		value = value
		dims = value2.dims
		elems = value2.elems
		switch( ntype ){
		case DAO_FLOAT   ,
		case DAO_DOUBLE  : size *= 2;
		case DAO_COMPLEX : size *= 4;
		}
		for( i = 1 : ndim ) dims.append( DecodeDaoInt() );
		for( i = 1 : size ) elems.append( DecodeDaoInt() );
	case DAO_LIST :
		abtype = DecodeUInt32()
		size = DecodeDaoInt()
		value2 = ListValue{ tid, abtype, {} }
		value = value2
		items = value2.items
		io.writeln( size )
		for( i = 1 : size ) items.append( DecodeUInt32() );
	case DAO_TUPLE :
		abtype = DecodeUInt32()
		size = DecodeUInt32()
		value2 = ListValue{ tid, abtype, {} }
		value = value2
		items = value2.items
		for( i = 1 : size ) items.append( DecodeUInt32() );
	case DAO_MAP :
		abtype = DecodeUInt32()
		hashing = DecodeUInt32()
		size = DecodeDaoInt()
		value2 = MapValue{ tid, abtype, hashing, {} }
		value = value2
		items = value2.items
		for( i = 1 : 2*size ) items.append( DecodeUInt32() );
	case DAO_TYPE :
		abtype = DecodeUInt32()
		value = TypeValue{ tid, abtype }
	case DAO_OBJECT :
		flag = DecodeUInt8()
		dec = DecodeUInt32()
		if( flag == 0x0 ){
			num = DecodeUInt16()
			value2 = CompleteInstanceValue{ tid, flag, dec, {} }
			value = value2
			vals = value2.values
			for( i = 1 : num ) vals.append( DecodeUInt32() )
		}else if( flag == 0x1 ){
			offset = DecodeUInt16()
			host = DecodeUInt32()
			value = PartialInstanceValue{ tid, flag, dec, offset, host }
		}else{
			value = DefaultInstanceValue{ tid, flag, dec }
		}
	case DAO_CLASS ,
	case DAO_CTYPE ,
	case DAO_INTERFACE ,
	case DAO_NAMESPACE :
		dec = DecodeUInt32()
		value = ClassValue{ tid, dec }
	case DAO_CDATA :
	case DAO_ROUTINE :
		dec = DecodeUInt32()
		routype = DecodeUInt32()
		hostype = DecodeUInt32()
		flag = DecodeUInt8()
		value = RoutineValue{ tid, dec, routype, hostype, flag }
	case DAO_FUTURE :
		id = DecodeUInt32()
		value = FutureValue{ tid, id }
	case DAO_PAR_NAMED :
		name = DecodeUInt32();
		tp = DecodeUInt32();
		val = DecodeUInt32()
		value = NamedValue{ tid, name, tp, val }
	default :
		io.writeln( 'undecode value:', tid )
	}
	return value;
}
routine DaoByteCode::DecodeTypes()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeTypes()', count );
	for( i = 1 : count ){
		tid = DecodeUInt8();
		att = DecodeUInt8();
		name = DecodeUInt32();
		io.writef( '%5i %5i %5i    %s\n', i, tid, name , identifiers[name-1] )
		#io.writeln( identifiers[name-1] )
		switch( tid ){
		case DAO_NONE ,
		case DAO_INTEGER ,
		case DAO_FLOAT ,
		case DAO_DOUBLE ,
		case DAO_COMPLEX ,
		case DAO_LONG ,
		case DAO_STRING :
			types.append( CoreType{ tid, att, name } );
		case DAO_ENUM :
			subtype = DecodeUInt8();
			symcount = DecodeUInt16();
			enumType = EnumType{ tid, att, name, subtype, {} };
			symbols = enumType.symbols;
			for( j = 1 : symcount ) symbols.append( (DecodeUInt32(), DecodeUInt32()) );
			io.writeln( symbols );
			types.append( enumType );
		case DAO_ARRAY ,
		case DAO_LIST ,
		case DAO_MAP ,
		case DAO_TUPLE ,
		case DAO_TYPE ,
		case DAO_FUTURE :
			typeCount = DecodeUInt16();
			contype = ContainerType{ tid, att, name, {} };
			itypes = contype.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( contype )
		case DAO_OBJECT ,
		case DAO_CLASS ,
		case DAO_INTERFACE :
			dec = DecodeUInt32();
			types.append( InstanceType{ tid, att, name, dec } );
		case DAO_CDATA ,
		case DAO_CTYPE :
			dec = DecodeUInt32();
			typeCount = DecodeUInt16();
			tup = CdataType{ tid, att, name, dec, {} };
			itypes = tup.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( tup );
		case DAO_ROUTINE :
			dec = DecodeUInt32();
			retype = DecodeUInt32();
			cbtype = DecodeUInt32();
			typeCount = DecodeUInt16();
			tup = RoutineType{ tid, att, name, dec, retype, cbtype, {} };
			itypes = tup.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
			types.append( tup );
		case DAO_VARIANT ,
		case DAO_CODEBLOCK :
			typeCount = DecodeUInt16();
			holder = DecodeUInt32();
			contype = VariantType{ tid, att, name, holder, {} };
			itypes = contype.types;
			for( j = 1 : typeCount ) itypes.append( DecodeUInt32() );
		case DAO_PAR_NAMED ,
		case DAO_PAR_DEFAULT :
			fname = DecodeUInt32();
			ftype = DecodeUInt32();
			types.append( NameParamType{ tid, att, name, fname, ftype } );
		case DAO_VALTYPE :
			value = DecodeValue();
			types.append( ValueType{ tid, att, name, value } );
		default :
			types.append( CoreType{ tid, att, name } );
		}
	}
}
routine DaoByteCode::DecodeValues()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeValues()', count );
	for( i = 1 : count ){
		values.append( DecodeValue() )
	}
}
routine DaoByteCode::DecodeConstant()=>Constant
{
	name = DecodeUInt32()
	index = DecodeUInt16()
	perm = DecodeUInt8()
	value = DecodeUInt32()
	return Constant{ name, index, perm, value }
}
routine DaoByteCode::DecodeConstants()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeConstants()', count );
	for( i = 1 : count ) constants.append( DecodeConstant() )
}
routine DaoByteCode::DecodeVariable()=>Variable
{
	name = DecodeUInt32()
	index = DecodeUInt16()
	perm = DecodeUInt8()
	typeid = DecodeUInt32()
	value = DecodeUInt32()
	return Variable{ name, index, perm, typeid, value }
}
routine DaoByteCode::DecodeVariables()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeVariables()', count );
	for( i = 1 : count ) variables.append( DecodeVariable() )
}
routine DaoByteCode::DecodeGlobalTypes()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeGlobalTypes()', count );
	for( i = 1 : count ){
		name = DecodeUInt32()
		typeid = DecodeUInt32()
		typeDecls.append( TypeDecl{ name, typeid } )
	}
}
routine DaoByteCode::DecodeInterfaces()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeInterfaces()', count );
	for( i = 1 : count ){
		dec = DecodeUInt32()
		inter = Interface{ dec, {}, {} }
		bases = inter.bases
		meths = inter.methods
		count = DecodeUInt16()
		for( j = 1 : count ) bases.append( DecodeUInt32() )
		count = DecodeUInt16()
		for( j = 1 : count ) meths.append( DecodeUInt32() )
		interfaces.append( inter )
	}
}
routine DaoByteCode::DecodeClasses()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeClasses()', count );
	for( i = 1 : count ){
		classID = DecodeUInt32()
		cstrID = DecodeUInt32()
		attribs = DecodeUInt16()
		klass = Class{ classID, cstrID, attribs, {}, {}, {}, {}, {} }
		bases = klass.bases
		consts = klass.constants
		svars = klass.svariables
		ivars = klass.ivariables
		abtypes = klass.types
		for( j = 1 : DecodeUInt16() ) bases.append( DecodeUInt32() )
		for( j = 1 : DecodeUInt16() ) consts.append( DecodeConstant() )
		for( j = 1 : DecodeUInt16() ) svars.append( DecodeVariable() )
		for( j = 1 : DecodeUInt16() ) ivars.append( DecodeVariable() )
		for( j = 1 : DecodeUInt16() ) abtypes.append( TypeDecl{ DecodeUInt32(), DecodeUInt32() } )
		classes.append( klass )
	}
}
routine DaoByteCode::DecodeRoutines()
{
	count = DecodeUInt32();
	io.writeln( 'DecodeRoutines()', count );
	for( i = 1 : count ){
		routid = DecodeUInt32();
		nameid = DecodeUInt32();
		typeid = DecodeUInt32();
		hostid = DecodeUInt32();
		uproutid = DecodeUInt32();
		attribs = DecodeUInt16();
		line = DecodeUInt16();

		io.writef( '%5i   %s\n', i, identifiers[nameid-1] )

		rout = Routine{ routid, nameid, typeid, hostid, uproutid, attribs, line, {},0,{},{},{} }
		consts = rout.constants
		varTypes = rout.varTypes
		lineCounts = rout.lineCounts
		codes = rout.codes
		for( j = 1 : DecodeUInt16() ) consts.append( DecodeUInt32() )
		rout.varCount = DecodeUInt16()
		for( j = 1 : DecodeUInt16() ){
			index = DecodeUInt16()
			typeid = DecodeUInt32()
			varTypes.append( (index, typeid) )
		}
		for( j = 1 : DecodeUInt16() ){
			line = DecodeUInt16()
			count = DecodeUInt8()
			lineCounts.append( (line, count) )
		}
		for( j = 1 : DecodeUInt16() ){
			code = DecodeUInt16()
			a = DecodeUInt16()
			b = DecodeUInt16()
			c = DecodeUInt16()
			codes.append( Instruction{ code, a, b, c } )
		}
		routines.append( rout )
	}
}
routine DaoByteCode::Decode( bytecodes : string )
{
# "bytecodes" could be MBS, with character range [-127,127];
# Map it to WCS, so that the character range will become [0,255];
	data = bytecodes.map::{ (X+256)%256 }

	if( data.size() < 16 ) raise Exception::Error( 'Invalid bytecode file' );
	if( data[:3] != "\33Dao" ) raise Exception::Error( 'Not a Dao bytecode file' );

	header = data[:15];

	intSize = data[9];
	offset = 16;

	source = DecodeShortString();
	DecodeIdentifiers();
	DecodeModules();
	DecodeDeclarations();
	DecodeTypes();
	DecodeValues();
	DecodeConstants();
	DecodeVariables();
	DecodeGlobalTypes();
	DecodeInterfaces();
	DecodeClasses();
	DecodeRoutines();

	io.writeln( intSize, source );
	io.writeln( identifiers.size() );
	io.writeln( modules );
	io.writeln( declarations );
	io.writeln( types );
	io.writeln( values );
}


routine main( file : string )
{
	coder = DaoByteCode();
	coder.Decode( io.read( file ) );
}
